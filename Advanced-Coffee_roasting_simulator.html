<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holistic Roasters' Coffee Roaster Sim v3.2</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; display: flex; justify-content: center; align-items: flex-start; min-height: 100vh; background-color: #e8e8e8; margin: 0; padding: 20px; box-sizing: border-box; color: #333; }
        .container { background-color: #fdfdfd; padding: 25px; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.1); width: 100%; max-width: 950px; }
        h1, h2 { text-align: center; color: #2c3e50; margin-bottom: 20px; }
        .main-controls, .roast-parameters, .roast-info, .events, .outcome, .preheat-section, .profile-management { margin-bottom: 25px; padding: 15px; background-color: #f9f9f9; border: 1px solid #ddd; border-radius: 8px; }
        .main-controls, .profile-management { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; justify-content: space-around; }
        .main-controls button, .profile-management button, .profile-management input[type="file"] { padding: 10px 15px; border: none; border-radius: 6px; cursor: pointer; font-size: 0.95em; transition: background-color 0.2s ease, transform 0.1s ease; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .main-controls button:active, .profile-management button:active { transform: translateY(1px); }
        #preheatBtn { background-color: #3498db; color: white; }
        #chargeBtn { background-color: #f39c12; color: white; }
        #dropBtn { background-color: #e74c3c; color: white; }
        #resetBtn { background-color: #95a5a6; color: white; }
        .profile-management button { background-color: #2ecc71; color: white; }
        .profile-management button.secondary { background-color: #e67e22; }
        .profile-management button.tertiary { background-color: #8e44ad; }
        .main-controls button:disabled, .profile-management button:disabled { background-color: #bdc3c7; cursor: not-allowed; box-shadow: none; }
        .preheat-section { display: flex; gap: 15px; align-items: center; }
        .preheat-section label { font-weight: bold; }
        .preheat-section input[type="number"] { padding: 8px; border-radius: 4px; border: 1px solid #ccc; width: 80px; }
        .roast-parameters { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; }
        .param-control { display: flex; flex-direction: column; }
        .param-control label { margin-bottom: 8px; font-weight: bold; color: #555; }
        .param-control input[type="range"], .param-control select { width: 100%; margin-bottom: 5px; padding: 8px; border-radius: 4px; border: 1px solid #ccc; box-sizing: border-box; }
        .param-control span { font-size: 0.9em; color: #34495e; align-self: flex-end; }
        .roast-info { display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 8px; background-color: #ecf0f1; }
        .info-item { font-size: 0.9em; padding: 7px; background-color: #fff; border-radius: 5px; border: 1px solid #dcdcdc; text-align: center; }
        .info-item strong { display: block; margin-bottom: 3px; color: #2980b9; }
        .bean-visual-container { display: flex; flex-direction: column; align-items: center; justify-content: center; }
        #beanVisual { width: 25px; height: 25px; border: 1px solid #ccc; border-radius: 12px; margin-top: 4px; background-color: #90EE90; transition: background-color 0.5s ease, width 0.5s ease, height 0.5s ease; }
        .events ul { list-style-type: none; padding: 0; max-height: 120px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; border-radius: 5px; background-color: #fff; }
        .events ul li { padding: 5px 0; border-bottom: 1px dashed #eee; font-size: 0.9em; } 
        .events ul li:last-child { border-bottom: none; }
        .chart-container { width: 100%; height: 400px; margin-bottom: 20px; }
        .outcome { background-color: #e7f3fe; border-left: 6px solid #2196F3; padding: 15px; border-radius: 5px; }
        .outcome p { margin: 0; font-size: 1.1em; }
        /* Modal Styles */
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); justify-content: center; align-items: center; }
        .modal-content { background-color: #fefefe; margin: auto; padding: 20px; border: 1px solid #888; width: 80%; max-width: 500px; border-radius: 8px; }
        .modal-close { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
        .modal-content ul { list-style-type: none; padding: 0; }
        .modal-content li { padding: 8px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; }
        .modal-content li:last-child { border-bottom: none;}
        .modal-content button { font-size: 0.8em; padding: 5px 10px; margin-left: 5px;}
        #fileInput { display: none; } /* Hide default file input */
        #customImportButton { background-color: #1abc9c; color: white; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Holistic Roasters' Coffee Roaster Sim</h1>

        <div class="main-controls">
            <button id="preheatBtn">Preheat</button>
            <button id="chargeBtn" disabled>Charge Beans</button> 
            <button id="dropBtn" disabled>Drop Beans</button>
            <button id="resetBtn">Reset</button>
        </div>
        
        <div class="preheat-section">
            <label for="targetChargeTempDT">Target Charge DT (°C):</label>
            <input type="number" id="targetChargeTempDT" value="190" step="5">
            <span id="preheatStatus">Status: Idle</span>
        </div>

        <div class="profile-management">
            <button id="saveProfileBtn" class="secondary">Save Profile</button>
            <button id="loadProfileListBtn">Load Stored Profiles</button>
            <input type="file" id="fileInput" accept=".json">
            <button id="customImportButton">Import Profile (JSON)</button>
            <button id="exportProfileBtn" class="tertiary">Export Current Roast Data</button>
            <button id="clearReferenceBtn">Clear Reference Curve</button>
        </div>


        <div class="roast-parameters">
            <div class="param-control">
                <label for="batchSizeSelect">Batch Size:</label>
                <select id="batchSizeSelect">
                    <option value="10">10 kg</option>
                    <option value="15" selected>15 kg</option>
                    <option value="20">20 kg</option>
                    <option value="25">25 kg</option>
                </select>
                <span id="batchSizeDisplay">15 kg</span>
            </div>
            <div class="param-control">
                <label for="initialMoisture">Initial Moisture (%):</label>
                <input type="range" id="initialMoisture" min="8" max="12" value="10" step="0.5">
                <span id="initialMoistureDisplay">10.0 %</span>
            </div>
            <div class="param-control">
                <label for="beanDensitySlider">Bean Density (g/mL):</label>
                <input type="range" id="beanDensitySlider" min="1.10" max="1.25" value="1.18" step="0.01">
                <span id="beanDensityDisplay">1.18 g/mL</span>
            </div>
            <div class="param-control">
                <label for="gasSlider">Gas Power (%):</label>
                <input type="range" id="gasSlider" min="0" max="100" value="70" step="1">
                <span id="gasValueDisplay">70 %</span>
            </div>
            <div class="param-control">
                <label for="airflowSlider">Airflow Damper (%):</label>
                <input type="range" id="airflowSlider" min="0" max="100" value="20" step="1">
                <span id="airflowValueDisplay">20 %</span>
            </div>
            <div class="param-control">
                <label for="drumSpeedSlider">Drum Speed (RPM):</label>
                <input type="range" id="drumSpeedSlider" min="30" max="60" value="45" step="1">
                <span id="drumSpeedDisplay">45 RPM</span>
            </div>
        </div>

        <div class="roast-info">
            <div class="info-item"><strong>Time</strong><span id="timeDisplay">0:00</span></div>
            <div class="info-item"><strong>BT</strong><span id="btDisplay">20.0</span>°C</div>
            <div class="info-item"><strong>ET</strong><span id="etDisplay">20.0</span>°C</div>
            <div class="info-item"><strong>DT</strong><span id="dtDisplay">20.0</span>°C</div>
            <div class="info-item"><strong>RoR(BT)</strong><span id="rorDisplay">0.0</span>°C/m</div>
            <div class="info-item"><strong>Moisture</strong><span id="moistureDisplay">10.0</span>%</div>
            <div class="info-item bean-visual-container">
                <strong>Bean Color</strong> <div id="beanVisual"></div>
            </div>
        </div>

        <div class="events">
            <h2>Events Log:</h2>
            <ul id="eventLog"><li>Simulator Idle. Set Preheat Target, Batch Size, Moisture, Density, Drum Speed.</li></ul>
        </div>

        <div class="chart-container"><canvas id="roastChart"></canvas></div>
        <div id="roastOutcome" class="outcome"><p id="outcomeText">-</p></div>
    </div>

    <!-- Profile Management Modal -->
    <div id="profileModal" class="modal">
        <div class="modal-content">
            <span class="modal-close" id="modalCloseBtn">×</span>
            <h2>Saved Roast Profiles</h2>
            <ul id="profileList">
                <!-- Profiles will be listed here -->
            </ul>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // DOM Elements
        const preheatBtn = document.getElementById('preheatBtn');
        const chargeBtn = document.getElementById('chargeBtn');
        const dropBtn = document.getElementById('dropBtn');
        const resetBtn = document.getElementById('resetBtn');
        const targetChargeTempDTInput = document.getElementById('targetChargeTempDT');
        const preheatStatusDisplay = document.getElementById('preheatStatus');
        const batchSizeSelect = document.getElementById('batchSizeSelect');
        const batchSizeDisplay = document.getElementById('batchSizeDisplay');
        const initialMoistureSlider = document.getElementById('initialMoisture');
        const initialMoistureDisplay = document.getElementById('initialMoistureDisplay');
        const beanDensitySlider = document.getElementById('beanDensitySlider'); 
        const beanDensityDisplay = document.getElementById('beanDensityDisplay'); 
        const gasSlider = document.getElementById('gasSlider');
        const gasValueDisplay = document.getElementById('gasValueDisplay');
        const airflowSlider = document.getElementById('airflowSlider');
        const airflowValueDisplay = document.getElementById('airflowValueDisplay');
        const drumSpeedSlider = document.getElementById('drumSpeedSlider'); 
        const drumSpeedDisplay = document.getElementById('drumSpeedDisplay'); 
        const timeDisplay = document.getElementById('timeDisplay');
        const btDisplay = document.getElementById('btDisplay');
        const etDisplay = document.getElementById('etDisplay');
        const dtDisplay = document.getElementById('dtDisplay');
        const rorDisplay = document.getElementById('rorDisplay');
        const moistureDisplay = document.getElementById('moistureDisplay');
        const beanVisual = document.getElementById('beanVisual');
        const eventLog = document.getElementById('eventLog');
        const outcomeText = document.getElementById('outcomeText');
        const roastChartCanvas = document.getElementById('roastChart');

        // Profile Management DOM
        const saveProfileBtn = document.getElementById('saveProfileBtn');
        const loadProfileListBtn = document.getElementById('loadProfileListBtn');
        const fileInput = document.getElementById('fileInput');
        const customImportButton = document.getElementById('customImportButton');
        const exportProfileBtn = document.getElementById('exportProfileBtn');
        const clearReferenceBtn = document.getElementById('clearReferenceBtn');
        const profileModal = document.getElementById('profileModal');
        const modalCloseBtn = document.getElementById('modalCloseBtn');
        const profileList = document.getElementById('profileList');

        let audioCtx = null;
        try {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) { console.warn("Web Audio API is not supported."); }

        // Roast State
        let timerInterval = null, currentTime = 0, roastPhaseTimer = 0, coolingTimer = 0;
        let currentBT = 20, currentET = 20, currentDT = 20, currentRoR = 0;
        let currentMoisturePercent = parseFloat(initialMoistureSlider.value);
        let currentBeanDensity = parseFloat(beanDensitySlider.value); 
        let targetGasSetting = parseInt(gasSlider.value), effectiveGas = 0; 
        let targetAirflowSetting = parseInt(airflowSlider.value), effectiveAirflow = 0; 
        let targetDrumSpeed = parseInt(drumSpeedSlider.value), effectiveDrumSpeed = 30; 
        let batchSize = parseFloat(batchSizeSelect.value);
        let targetChargeTempDT = parseFloat(targetChargeTempDTInput.value);
        let roastState = 'idle'; // idle, preheating, charged, cooling, dropped
        let firstCrackTime = null, firstCrackTemp = null, firstCrackLogged = false;
        let secondCrackTime = null, secondCrackTemp = null, secondCrackLogged = false, inSCPhase = false;
        let inFCExothermicPhase = false, fcExothermicTimer = 0;
        let crackSoundInterval = null;
        let preDropBT = 0; 

        // For saving profiles
        let controlChanges = []; 
        let initialRoastParams = {};

        // Chart Data
        let chart;
        let tempDataPointsBT = []; 
        const MAX_TEMP_DATA_POINTS_FOR_ROR = 180; 

        const getBaseChartDataStructure = () => ({
            labels: [],
            datasets: [
                { label: 'BT (°C)', data: [], borderColor: 'rgb(220, 53, 69)', yAxisID: 'y-temp', tension: 0.2, fill: false, pointRadius: 1, borderWidth: 2 },
                { label: 'ET (°C)', data: [], borderColor: 'rgb(0, 123, 255)', yAxisID: 'y-temp', tension: 0.2, fill: false, pointRadius: 1, borderWidth: 2 },
                { label: 'DT (°C)', data: [], borderColor: 'rgb(255, 193, 7)', yAxisID: 'y-temp', tension: 0.2, fill: false, pointRadius: 1, borderWidth: 2 },
                { label: 'RoR (°C/min)', data: [], borderColor: 'rgb(40, 167, 69)', yAxisID: 'y-ror', tension: 0.2, fill: false, borderDash: [5, 5], pointRadius: 1, borderWidth: 2 },
                { label: 'Ref BT (°C)', data: [], borderColor: 'rgba(220, 53, 69, 0.4)', yAxisID: 'y-temp', tension: 0.2, fill: false, pointRadius: 0, borderDash: [3,3], borderWidth: 1.5, hidden: true },
                { label: 'Ref ET (°C)', data: [], borderColor: 'rgba(0, 123, 255, 0.4)', yAxisID: 'y-temp', tension: 0.2, fill: false, pointRadius: 0, borderDash: [3,3], borderWidth: 1.5, hidden: true },
                { label: 'Ref DT (°C)', data: [], borderColor: 'rgba(255, 193, 7, 0.4)', yAxisID: 'y-temp', tension: 0.2, fill: false, pointRadius: 0, borderDash: [3,3], borderWidth: 1.5, hidden: true },
                { label: 'Ref RoR (°C/min)', data: [], borderColor: 'rgba(40, 167, 69, 0.4)', yAxisID: 'y-ror', tension: 0.2, fill: false, borderDash: [3,3], pointRadius: 0, borderWidth: 1.5, hidden: true }
            ]
        });
        let chartData = getBaseChartDataStructure();
    
        // Constants
        const AMBIENT_TEMP = 20;
        const GAS_INERTIA_FACTOR = 0.08; 
        const AIRFLOW_INERTIA_FACTOR = 0.1;
        const DRUM_SPEED_INERTIA_FACTOR = 0.15; 
        
        // MODIFIED PARAMETERS TO SLOW DOWN THE ROAST
        const DT_HEAT_FROM_GAS_FACTOR = 0.030;       // Original: 0.035 - Roaster drum heats slightly slower from gas
        const ET_GAIN_FROM_GAS_AIR = 0.020;          // Original: 0.025 - Roaster environment heats slightly slower from gas/air
        const BT_CONDUCTIVE_FROM_DT_BASE = 0.0035;   // Original: 0.008 - Reduced conductive heat transfer to beans
        const BT_CONVECTIVE_FROM_ET_AIR_BASE = 0.0025; // Original: 0.006 - Reduced convective heat transfer to beans
        // END OF MODIFIED PARAMETERS

        const DT_INERTIA_FACTOR = 0.03;       
        const DT_COOLING_AMBIENT_FACTOR = 0.0005;
        const DT_COOLING_FROM_BEANS_FACTOR = 0.05; 
        const PREHEAT_ET_FROM_DT_FACTOR = 0.8; 
        const PREHEAT_ET_AIRFLOW_EFFECT = 0.05; 
        const BT_INITIAL_ABSORB_FROM_DT_FACTOR = 0.6; 
        const ET_DROP_ON_CHARGE_FACTOR = 0.5;  
        const MOISTURE_EVAPORATION_BT_FACTOR = 0.0002;    
        const MOISTURE_EVAPORATION_AIRFLOW_FACTOR = 0.0003; 
        const MOISTURE_MIN_PERCENT = 1.0;
        const DRYING_ENDOTHERMIC_STRENGTH = 0.05;     
        const DRYING_PHASE_MOISTURE_THRESHOLD = 4.0; 
        const BT_THERMAL_MASS_PENALTY_PER_KG = 0.00003; 
        const ET_INFLUENCE_FROM_DT = 0.01;        
        const ET_INFLUENCE_FROM_BT_EXCHANGE = 0.005; 
        const ET_AIRFLOW_COOLING_NO_GAS = 0.006;  
        const ET_NATURAL_COOLING_FACTOR = 0.0015;
        const FC_ENDOTHERMIC_DIP_TEMP_RANGE = 4; 
        const FC_ENDOTHERMIC_DIP_STRENGTH = 0.10; 
        const FC_EXOTHERMIC_BOOST_STRENGTH = 0.001; 
        const FC_EXOTHERMIC_DURATION = 25; 
        const SC_TARGET_TEMP_OFFSET = 25; 
        const SC_EXOTHERMIC_DURATION = 20; 
        const OPTIMAL_DRUM_SPEED_RPM = 48;
        const DRUM_SPEED_EFFICIENCY_FACTOR_CONDUCTIVE = 0.15; 
        const DRUM_SPEED_EFFICIENCY_FACTOR_CONVECTIVE = 0.20; 
        const BASE_BEAN_DENSITY = 1.18; 
        const DENSITY_TP_BT_MODIFIER = 0.3; 
        const DENSITY_CONDUCTIVE_MULTIPLIER = 0.8; 
        const DENSITY_INERTIA_MULTIPLIER = 0.4; 
        const DENSITY_FC_TEMP_SHIFT_PER_0_01GDL = 0.15;
        const COOLING_RATE_FACTOR = 0.08; 
        const COOLING_TARGET_TEMP = 35; 
        const BEAN_VISUAL_DRYING_END_BT = 160;
        const BEAN_VISUAL_FC_START_BT_FACTOR = 0.98; 

        function formatTime(seconds) { return `${Math.floor(seconds/60)}:${(Math.floor(seconds%60)+'').padStart(2,'0')}`; }
        function safeToFixed(value, digits = 1) { return (typeof value === 'number' && !isNaN(value)) ? value.toFixed(digits) : "NaN"; }

        function playCrackSound(type = 'firstCrack') {
            if (!audioCtx) return;
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            gainNode.gain.setValueAtTime(0.05, audioCtx.currentTime); 
            let baseFreq = type === 'firstCrack' ? 300 : 450;
            let duration = type === 'firstCrack' ? 0.15 : 0.1;
            oscillator.type = type === 'firstCrack' ? 'sawtooth' : 'triangle';
            oscillator.frequency.setValueAtTime(baseFreq + (Math.random() * 100 - 50), audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + duration);
            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + duration + 0.05);
        }
        function manageCrackSounds(enable, type) {
            if (enable) {
                if (crackSoundInterval) clearInterval(crackSoundInterval); 
                crackSoundInterval = setInterval(() => {
                    playCrackSound(type);
                }, Math.random() * (type === 'firstCrack' ? 1500 : 1000) + (type === 'firstCrack' ? 500 : 200)); 
            } else {
                if (crackSoundInterval) clearInterval(crackSoundInterval);
                crackSoundInterval = null;
            }
        }
        function updateUIDisplays() {
            let displayTime;
            if (roastState === 'preheating') displayTime = currentTime;
            else if (roastState === 'charged' || roastState === 'cooling') displayTime = roastPhaseTimer;
            else if (roastState === 'dropped') displayTime = roastPhaseTimer;
            else displayTime = currentTime; 

            timeDisplay.textContent = formatTime(displayTime);
            btDisplay.textContent = safeToFixed(currentBT);
            etDisplay.textContent = safeToFixed(currentET);
            dtDisplay.textContent = safeToFixed(currentDT);
            rorDisplay.textContent = safeToFixed(currentRoR);
            moistureDisplay.textContent = safeToFixed(currentMoisturePercent);
            gasValueDisplay.textContent = `${targetGasSetting}% (Eff: ${safeToFixed(effectiveGas,0)})`;
            airflowValueDisplay.textContent = `${targetAirflowSetting}% (Eff: ${safeToFixed(effectiveAirflow,0)})`;
            drumSpeedDisplay.textContent = `${targetDrumSpeed}RPM (Eff: ${safeToFixed(effectiveDrumSpeed,0)})`;
            batchSizeDisplay.textContent = `${batchSize} kg`;
            initialMoistureDisplay.textContent = `${safeToFixed(parseFloat(initialMoistureSlider.value),1)}%`;
            beanDensityDisplay.textContent = `${safeToFixed(parseFloat(beanDensitySlider.value), 2)} g/mL`; 
            targetChargeTempDTInput.value = safeToFixed(targetChargeTempDT,0);
            updateBeanVisual();
        }
        function updateBeanVisual() {
            let color = '#D2B48C'; let size = 25; 
            const fcActualTemp = firstCrackTemp || (195 + ((currentBeanDensity - BASE_BEAN_DENSITY) / 0.01) * DENSITY_FC_TEMP_SHIFT_PER_0_01GDL);
            if (currentBT <= AMBIENT_TEMP + 5 && currentMoisturePercent > 8) { color = '#90EE90'; } 
            else if (currentBT < 100) { color = '#A5D6A7'; } else if (currentBT < 130) { color = '#FFF59D'; } 
            else if (currentBT < BEAN_VISUAL_DRYING_END_BT) { color = '#FFEE58'; size = 27; } 
            else if (currentBT < fcActualTemp * BEAN_VISUAL_FC_START_BT_FACTOR) { color = '#F5DEB3'; size = 28; } 
            else if (currentBT < fcActualTemp + 5) { color = '#D2B48C'; size = 30; } 
            else if (currentBT < fcActualTemp + 12) { color = '#C19A6B'; size = 30;} 
            else if (currentBT < fcActualTemp + SC_TARGET_TEMP_OFFSET - 5) { color = '#A05A2C'; } 
            else if (currentBT < fcActualTemp + SC_TARGET_TEMP_OFFSET + 5) { color = '#80451E'; } 
            else if (currentBT < 235) { color = '#65360F'; } else if (currentBT < 245) { color = '#4A2500'; } 
            else { color = '#2F1700'; } 
            beanVisual.style.backgroundColor = color; beanVisual.style.width = `${size}px`;
            beanVisual.style.height = `${size}px`; beanVisual.style.borderRadius = `${size/2}px`;
        }
        function logEvent(message, isCritical = false) {
            const li = document.createElement('li');
            let timeMarker = `Sim [${formatTime(currentTime)}]`;
            if (roastState === 'preheating') timeMarker = `PHeat [${formatTime(currentTime)}]`;
            else if (roastState === 'charged' || roastState === 'cooling') timeMarker = `Roast [${formatTime(roastPhaseTimer)}]`;
            else if (roastState === 'dropped') timeMarker = `Roast [${formatTime(roastPhaseTimer)}] (Dropped)`;
            li.textContent = `${timeMarker} ${message}`;
            if (isCritical) li.style.fontWeight = 'bold';
            if (eventLog.firstChild && eventLog.firstChild.textContent.includes("Simulator Idle")) eventLog.removeChild(eventLog.firstChild);
            eventLog.insertBefore(li, eventLog.firstChild);
        }
        function calculateRoR() {
            const windowSeconds = 30; if (tempDataPointsBT.length < 2) return 0;
            const relevantData = tempDataPointsBT.filter(dp => roastPhaseTimer - dp.time <= windowSeconds && dp.time <= roastPhaseTimer);
            if (relevantData.length < 2) {
                if (tempDataPointsBT.length >=2) {
                    const firstPoint = tempDataPointsBT[0], lastPoint = tempDataPointsBT[tempDataPointsBT.length -1];
                    if (isNaN(firstPoint.temp) || isNaN(lastPoint.temp)) return 0; 
                    const tempChange = lastPoint.temp - firstPoint.temp, timeChange = (lastPoint.time - firstPoint.time) / 60; 
                    return timeChange > 0 ? (tempChange / timeChange) : 0;
                } return 0;
            }
            const firstPointInWindow = relevantData[0], lastPointInWindow = relevantData[relevantData.length - 1];
            if (isNaN(firstPointInWindow.temp) || isNaN(lastPointInWindow.temp)) return 0; 
            const tempChange = lastPointInWindow.temp - firstPointInWindow.temp, timeChangeInMinutes = (lastPointInWindow.time - firstPointInWindow.time) / 60;
            return timeChangeInMinutes > 0 ? (tempChange / timeChangeInMinutes) : 0;
        }
        function updateRoR() { currentRoR = parseFloat(calculateRoR()); }

        function initializeChart() {
            const ctx = roastChartCanvas.getContext('2d'); if (chart) chart.destroy();
            chartData = getBaseChartDataStructure(); 
            chart = new Chart(ctx, { type: 'line', data: chartData, options: { 
                responsive: true, maintainAspectRatio: false, interaction: { mode: 'index', intersect: false },
                scales: { x: { title: { display: true, text: 'Time (min:sec)' } },
                    'y-temp': { type: 'linear', display: true, position: 'left', title: { display: true, text: 'Temperature (°C)' }, suggestedMin: 0, suggestedMax: 280 },
                    'y-ror': { type: 'linear', display: true, position: 'right', title: { display: true, text: 'RoR (°C/min)' }, suggestedMin: -5, suggestedMax: 30, grid: { drawOnChartArea: false } }
                }, animation: { duration: 0 }, plugins: { tooltip: { callbacks: {
                    label: function(context) { let label = context.dataset.label || ''; if (label) label += ': ';
                        if (context.parsed.y !== null && !isNaN(context.parsed.y)) { label += context.parsed.y.toFixed(1);
                            if (context.dataset.yAxisID === 'y-temp') label += ' °C'; else if (context.dataset.yAxisID === 'y-ror') label += ' °C/min';
                        } else label += '...'; return label;
                }}}}}});
        }

        function updateChart() {
            if (!chart) return;

            if (roastState === 'idle' && chartData.labels.length > 0 && !timerInterval) {
                 chart.update('none'); 
                 return;
            }

            if (roastState === 'dropped' && currentBT <= COOLING_TARGET_TEMP) {
                if (chartData.datasets[0].data.length > 0) chart.update('none'); 
                return;
            }
            
            if (roastState !== 'idle' || timerInterval) { 
                let currentChartTimeLabel = formatTime(currentTime);
                if (chartData.labels.length === 0 || chartData.labels[chartData.labels.length - 1] !== currentChartTimeLabel) {
                    chartData.labels.push(currentChartTimeLabel);
                }
            }

            const currentDataLength = chartData.datasets[0].data.length;
            const labelsLength = chartData.labels.length;

            if (roastState !== 'idle' || (roastState === 'idle' && timerInterval) || currentDataLength < labelsLength) {
                 if (currentDataLength < labelsLength || labelsLength === 0 ) { 
                     chartData.datasets[0].data.push(isNaN(currentBT) ? null : parseFloat(currentBT.toFixed(1))); 
                     chartData.datasets[1].data.push(isNaN(currentET) ? null : parseFloat(currentET.toFixed(1)));
                     chartData.datasets[2].data.push(isNaN(currentDT) ? null : parseFloat(currentDT.toFixed(1))); 
                     chartData.datasets[3].data.push((roastState === 'charged' && !isNaN(currentRoR)) ? parseFloat(currentRoR.toFixed(1)) : null);
                } else if (currentDataLength === labelsLength && labelsLength > 0) {
                    chartData.datasets[0].data[labelsLength - 1] = isNaN(currentBT) ? null : parseFloat(currentBT.toFixed(1));
                    chartData.datasets[1].data[labelsLength - 1] = isNaN(currentET) ? null : parseFloat(currentET.toFixed(1));
                    chartData.datasets[2].data[labelsLength - 1] = isNaN(currentDT) ? null : parseFloat(currentDT.toFixed(1));
                    chartData.datasets[3].data[labelsLength - 1] = (roastState === 'charged' && !isNaN(currentRoR)) ? parseFloat(currentRoR.toFixed(1)) : null;
                }
            }


            const maxDataPointsOnChart = 900; 
            if (chartData.labels.length > maxDataPointsOnChart) { 
                chartData.labels.shift(); 
                if(roastState !== 'idle' || timerInterval) {
                    for (let i = 0; i <= 3; i++) {
                        if (chartData.datasets[i].data.length > 0) { 
                            chartData.datasets[i].data.shift();
                        }
                    }
                }
            }
            chart.update('none'); 
        }

        function simulationTick() {
            try { 
                currentTime++; 
                effectiveGas += (targetGasSetting - effectiveGas) * GAS_INERTIA_FACTOR;
                effectiveAirflow += (targetAirflowSetting - effectiveAirflow) * AIRFLOW_INERTIA_FACTOR;
                effectiveDrumSpeed += (targetDrumSpeed - effectiveDrumSpeed) * DRUM_SPEED_INERTIA_FACTOR; 
                effectiveGas = Math.max(0, Math.min(100, effectiveGas));
                effectiveAirflow = Math.max(0, Math.min(100, effectiveAirflow));
                effectiveDrumSpeed = Math.max(30, Math.min(60, effectiveDrumSpeed)); 
            
                let dtTarget = AMBIENT_TEMP + (effectiveGas * DT_HEAT_FROM_GAS_FACTOR * 100); 
                currentDT += (dtTarget - currentDT) * DT_INERTIA_FACTOR;
                currentDT -= (currentDT - AMBIENT_TEMP) * DT_COOLING_AMBIENT_FACTOR;
                currentDT = Math.max(AMBIENT_TEMP, currentDT);

                if (roastState === 'preheating') { 
                    roastPhaseTimer = 0; coolingTimer = 0;
                    let targetETForPreheat = currentDT * PREHEAT_ET_FROM_DT_FACTOR + (effectiveAirflow - 50) * PREHEAT_ET_AIRFLOW_EFFECT;
                    currentET += (targetETForPreheat - currentET) * 0.1; 
                    currentET = Math.max(AMBIENT_TEMP, Math.min(currentET, currentDT + 20)); 
                    currentBT = AMBIENT_TEMP; currentRoR = 0;
                    if (currentDT >= targetChargeTempDT && !isNaN(targetChargeTempDT)) {
                        if (!preheatStatusDisplay.textContent.includes("Ready to Charge")) {
                             logEvent(`Preheat target ${targetChargeTempDT}°C reached. Ready to charge.`);
                        }
                        preheatStatusDisplay.textContent = `Target Reached. Ready to Charge. DT: ${safeToFixed(currentDT)}°C`;
                    } else {
                        preheatStatusDisplay.textContent = `PHeat... DT: ${safeToFixed(currentDT)} ET: ${safeToFixed(currentET)}`;
                    }
                } else if (roastState === 'charged') {
                    roastPhaseTimer++; coolingTimer = 0; 
                    if (currentMoisturePercent > MOISTURE_MIN_PERCENT && !isNaN(currentMoisturePercent)) { 
                        let moistureLoss = 0;
                        if (currentBT > AMBIENT_TEMP + 10) {
                            moistureLoss += (currentBT - (AMBIENT_TEMP + 10)) * MOISTURE_EVAPORATION_BT_FACTOR;
                            moistureLoss += (effectiveAirflow / 100) * MOISTURE_EVAPORATION_AIRFLOW_FACTOR;
                        }
                        if(!isNaN(moistureLoss)) currentMoisturePercent -= moistureLoss;
                        currentMoisturePercent = Math.max(MOISTURE_MIN_PERCENT, currentMoisturePercent);
                    }
                    let drumSpeedDiff = Math.abs(effectiveDrumSpeed - OPTIMAL_DRUM_SPEED_RPM);
                    let conductiveEfficiency = 1.0 - (drumSpeedDiff / (OPTIMAL_DRUM_SPEED_RPM - 30)) * DRUM_SPEED_EFFICIENCY_FACTOR_CONDUCTIVE; 
                    let convectiveEfficiency = 1.0 - (drumSpeedDiff / (OPTIMAL_DRUM_SPEED_RPM - 30)) * DRUM_SPEED_EFFICIENCY_FACTOR_CONVECTIVE;
                    conductiveEfficiency = Math.max(1.0 - DRUM_SPEED_EFFICIENCY_FACTOR_CONDUCTIVE, Math.min(1.0, conductiveEfficiency)); 
                    convectiveEfficiency = Math.max(1.0 - DRUM_SPEED_EFFICIENCY_FACTOR_CONVECTIVE, Math.min(1.0, convectiveEfficiency)); 
                    const densityDiff = currentBeanDensity - BASE_BEAN_DENSITY;
                    const densityConductiveFactor = 1.0 + (densityDiff * DENSITY_CONDUCTIVE_MULTIPLIER);
                    let btConductiveGain = (currentDT - currentBT) * BT_CONDUCTIVE_FROM_DT_BASE * conductiveEfficiency * densityConductiveFactor; 
                    let airflowBoostFactor = 0.5 + (effectiveAirflow / 100) * 1.5; 
                    let btConvectiveGain = (currentET - currentBT) * BT_CONVECTIVE_FROM_ET_AIR_BASE * airflowBoostFactor * convectiveEfficiency; 
                    btConvectiveGain = Math.max(0, btConvectiveGain); 
                    let endothermicDryingEffect = 0;
                    if (currentMoisturePercent > DRYING_PHASE_MOISTURE_THRESHOLD && !isNaN(currentMoisturePercent) && !isNaN(parseFloat(initialMoistureSlider.value)) && parseFloat(initialMoistureSlider.value) !== 0) {
                        endothermicDryingEffect = (btConductiveGain + btConvectiveGain) * DRYING_ENDOTHERMIC_STRENGTH * (currentMoisturePercent / parseFloat(initialMoistureSlider.value));
                    }
                    const fcTargetTemp = 195 + ((densityDiff) / 0.01) * DENSITY_FC_TEMP_SHIFT_PER_0_01GDL;
                    const scTargetTemp = fcTargetTemp + SC_TARGET_TEMP_OFFSET;
                    let fcEndothermicDipFactor = 1.0;
                    if (!firstCrackTime && currentBT > (fcTargetTemp - FC_ENDOTHERMIC_DIP_TEMP_RANGE) && currentBT < fcTargetTemp) {
                        fcEndothermicDipFactor = 1.0 - FC_ENDOTHERMIC_DIP_STRENGTH;
                    }
                    let fcExothermicBoost = 0;
                    if (inFCExothermicPhase) { 
                        fcExothermicBoost = FC_EXOTHERMIC_BOOST_STRENGTH; fcExothermicTimer++;
                        if (fcExothermicTimer > FC_EXOTHERMIC_DURATION) { 
                            inFCExothermicPhase = false; fcExothermicTimer = 0; manageCrackSounds(false, 'firstCrack'); 
                            logEvent("First Crack Exothermic Phase ended.");
                        }
                    }
                    let scExothermicBoost = 0; if (inSCPhase) { /* SC exothermic logic */ }
                    let thermalMassFactor = 1 - (batchSize / 50) * BT_THERMAL_MASS_PENALTY_PER_KG * (currentDT);
                    thermalMassFactor = Math.max(0.2, thermalMassFactor); 
                    let deltaBT = ((btConductiveGain + btConvectiveGain) * fcEndothermicDipFactor - endothermicDryingEffect + fcExothermicBoost + scExothermicBoost) * thermalMassFactor;
                    const densityInertiaFactor = 1.0 - (densityDiff * DENSITY_INERTIA_MULTIPLIER); 
                    if (!isNaN(deltaBT)) deltaBT *= densityInertiaFactor;
                    if (isNaN(deltaBT)) { console.error(`deltaBT is NaN...`); logEvent(`SIM WARN: deltaBT NaN.`, true);
                    } else currentBT += deltaBT;
                    currentBT = Math.max(AMBIENT_TEMP - 10, currentBT); 
                    tempDataPointsBT.push({ time: roastPhaseTimer, temp: currentBT });
                    if (tempDataPointsBT.length > MAX_TEMP_DATA_POINTS_FOR_ROR) tempDataPointsBT.shift();
                    updateRoR();
                    let etGasAirFactor = (effectiveGas / 100) * (0.5 + effectiveAirflow / 200); 
                    let targetET = AMBIENT_TEMP + (effectiveGas * ET_GAIN_FROM_GAS_AIR * 50); 
                    targetET += (currentDT - targetET) * ET_INFLUENCE_FROM_DT; 
                    targetET += (currentBT - targetET) * ET_INFLUENCE_FROM_BT_EXCHANGE; 
                    if (effectiveGas < 15 && effectiveAirflow > 30) targetET -= (currentET - AMBIENT_TEMP) * (effectiveAirflow / 100) * ET_AIRFLOW_COOLING_NO_GAS;
                    currentET += (targetET - currentET) * 0.15; 
                    currentET -= (currentET - AMBIENT_TEMP) * ET_NATURAL_COOLING_FACTOR;
                    currentET = Math.max(AMBIENT_TEMP, Math.min(currentET, currentDT + 50)); 
                    if (currentBT >= fcTargetTemp && !firstCrackTime) { 
                        firstCrackTime = roastPhaseTimer; firstCrackTemp = currentBT; 
                        logEvent(`First Crack @ BT ${safeToFixed(currentBT)}°C (Target: ${safeToFixed(fcTargetTemp,1)}°C, Density: ${safeToFixed(currentBeanDensity,2)} g/mL, Moisture: ${safeToFixed(currentMoisturePercent)}%)`, true); 
                        if (!firstCrackLogged) { manageCrackSounds(true, 'firstCrack'); firstCrackLogged = true; } 
                        inFCExothermicPhase = true; fcExothermicTimer = 0; 
                    }
                    if (currentBT >= scTargetTemp && firstCrackTime && !secondCrackTime) { 
                        secondCrackTime = roastPhaseTimer; secondCrackTemp = currentBT; 
                        logEvent(`Second Crack @ BT ${safeToFixed(currentBT)}°C`, true); 
                        if (!secondCrackLogged) { manageCrackSounds(true, 'secondCrack'); secondCrackLogged = true; inSCPhase = true; }
                        if(inFCExothermicPhase) { 
                            manageCrackSounds(false, 'firstCrack'); inFCExothermicPhase = false; 
                            logEvent("First Crack sounds stopped due to Second Crack onset.");
                        }
                    }
                    if (currentBT >= 255 && roastState === 'charged') { logEvent(`DANGER! High BT. Auto-drop @ ${safeToFixed(currentBT)}°C`, true); handleDropBeans(); }
                } else if (roastState === 'cooling') {
                    roastPhaseTimer++; coolingTimer++;
                    let coolingEffectiveness = COOLING_RATE_FACTOR * (1 + effectiveAirflow / 200); 
                    if (currentBT > COOLING_TARGET_TEMP) {
                        currentBT -= (currentBT - AMBIENT_TEMP/2) * coolingEffectiveness; 
                        currentET -= (currentET - AMBIENT_TEMP) * (coolingEffectiveness * 1.5); 
                        currentDT -= (currentDT - AMBIENT_TEMP) * (coolingEffectiveness * 0.5); 
                    } else {
                        currentBT = COOLING_TARGET_TEMP; roastState = 'dropped'; stopSimulationTimer(); manageCrackSounds(false); 
                        logEvent(`Cooling complete. Final BT: ${safeToFixed(currentBT)}°C. Cooling Time: ${formatTime(coolingTimer)}`, true);
                        dropBtn.textContent = "Drop Beans"; 
                        let dtrPercent = 0; const roastDurationPreCooling = roastPhaseTimer - coolingTimer;
                        if (firstCrackTime && roastDurationPreCooling > firstCrackTime && roastDurationPreCooling > 0) {
                            const developmentTime = roastDurationPreCooling - firstCrackTime;
                            dtrPercent = (developmentTime / roastDurationPreCooling) * 100;
                        }
                        let finalOutcome = `<h2>Roast Outcome:</h2><p>Drop BT (pre-cool): ${safeToFixed(preDropBT,1)}°C. Roast Time (to drop): ${formatTime(roastDurationPreCooling)}. DTR: ${safeToFixed(dtrPercent)}%. Final BT (post-cool): ${safeToFixed(currentBT)}°C @ Total Roast Phase Time: ${formatTime(roastPhaseTimer)}. Moisture: ${safeToFixed(currentMoisturePercent)}%. Density: ${safeToFixed(currentBeanDensity,2)} g/mL. `;
                        if (preDropBT < 185) finalOutcome += "Underdeveloped.";
                        else if (preDropBT < 198) finalOutcome += `Cinnamon/Light. (DTR ${dtrPercent < 15 ? "low" : dtrPercent > 22 ? "high" : "ok"})`;
                        else if (preDropBT < 210) finalOutcome += `City/Medium-Light. (DTR ${dtrPercent < 16 ? "low" : dtrPercent > 24 ? "high" : "ok"})`;
                        else if (preDropBT < 220) finalOutcome += `Full City/Medium.`; else if (preDropBT < 228) finalOutcome += `Vienna/Medium-Dark.`;
                        else if (preDropBT < 235) finalOutcome += `French/Dark.`; else finalOutcome += "Likely Burnt!";
                        outcomeText.innerHTML = finalOutcome; logEvent(finalOutcome.replace(/<[^>]*>?/gm, ''));
                    }
                     currentET = Math.max(AMBIENT_TEMP, currentET); currentDT = Math.max(AMBIENT_TEMP, currentDT);
                }
                updateUIDisplays(); updateChart();
            } catch (error) { 
                console.error("Error in simulationTick:", error, error.stack); 
                logEvent(`SIMULATION ERROR: ${error.message}. Sim Halted.`, true); 
                stopSimulationTimer(); preheatStatusDisplay.textContent = "ERROR! Sim Halted."; 
            }
        }
    
        function startSimulationTimer() { if (!timerInterval) timerInterval = setInterval(simulationTick, 1000); }
        function stopSimulationTimer() { manageCrackSounds(false); clearInterval(timerInterval); timerInterval = null; }
        
        function handlePreheat() {
            if (roastState !== 'idle') return;
            resetRoastEssentialsForNewRoast(); 
            targetChargeTempDT = parseFloat(targetChargeTempDTInput.value);
            if (isNaN(targetChargeTempDT) || targetChargeTempDT < AMBIENT_TEMP || targetChargeTempDT > 300) {
                alert(`Invalid Target Charge DT.`); targetChargeTempDTInput.value = "190"; targetChargeTempDT = 190; return;
            }
            roastState = 'preheating'; currentTime = 0; 
            currentDT = AMBIENT_TEMP; currentET = AMBIENT_TEMP; currentBT = AMBIENT_TEMP; currentRoR = 0;
            currentMoisturePercent = parseFloat(initialMoistureSlider.value); 
            currentBeanDensity = parseFloat(beanDensitySlider.value); 
            batchSize = parseFloat(batchSizeSelect.value);
            effectiveDrumSpeed = parseInt(drumSpeedSlider.value);
            initialRoastParams = { targetChargeTempDT, batchSize, initialMoisture: currentMoisturePercent, beanDensity: currentBeanDensity, initialDrumSpeed: effectiveDrumSpeed };
            logEvent(`Preheating. Target DT: ${targetChargeTempDT}°C. Batch: ${batchSize}kg. Moisture: ${safeToFixed(currentMoisturePercent)}%. Density: ${safeToFixed(currentBeanDensity,2)} g/mL. Drum: ${effectiveDrumSpeed}RPM.`);
            preheatStatusDisplay.textContent = `PHeat... DT: ${safeToFixed(currentDT)}`;
            targetChargeTempDTInput.disabled = true; batchSizeSelect.disabled = true; 
            initialMoistureSlider.disabled = true; beanDensitySlider.disabled = true; 
            preheatBtn.disabled = true; chargeBtn.disabled = false; resetBtn.disabled = false;
            startSimulationTimer();
        }
        function handleChargeBeans() {
            if (roastState !== 'preheating' && roastState !== 'idle') return;
            if (roastState === 'idle') {
                if (!confirm("Preheat not initiated. Charge with ambient settings?")) return;
                resetRoastEssentialsForNewRoast(); currentTime = 0;
                currentMoisturePercent = parseFloat(initialMoistureSlider.value);
                currentBeanDensity = parseFloat(beanDensitySlider.value);
                batchSize = parseFloat(batchSizeSelect.value);
                effectiveDrumSpeed = parseInt(drumSpeedSlider.value); 
                initialRoastParams = { targetChargeTempDT: currentDT, batchSize, initialMoisture: currentMoisturePercent, beanDensity: currentBeanDensity, initialDrumSpeed: effectiveDrumSpeed };
            }
            roastState = 'charged'; roastPhaseTimer = 0; 
            const dtBeforeCharge = currentDT;
            currentDT -= (dtBeforeCharge - AMBIENT_TEMP) * (batchSize / 50) * DT_COOLING_FROM_BEANS_FACTOR; 
            currentET = AMBIENT_TEMP + (currentET - AMBIENT_TEMP) * (1 - ET_DROP_ON_CHARGE_FACTOR); 
            const densityDiff = currentBeanDensity - BASE_BEAN_DENSITY;
            const densityTpModifier = 1.0 + (densityDiff * DENSITY_TP_BT_MODIFIER);
            currentBT = AMBIENT_TEMP + (dtBeforeCharge - AMBIENT_TEMP) * BT_INITIAL_ABSORB_FROM_DT_FACTOR * (1 - batchSize/100) * densityTpModifier;
            currentBT = Math.max(AMBIENT_TEMP / 1.5, currentBT); 
            logEvent(`Beans Charged! DT: ${safeToFixed(currentDT)}, ET: ${safeToFixed(currentET)}, BT: ${safeToFixed(currentBT)} (TP). Moisture: ${safeToFixed(currentMoisturePercent)}%, Density: ${safeToFixed(currentBeanDensity,2)} g/mL`, true);
            preheatStatusDisplay.textContent = 'Beans Charged';
            if (roastState === 'idle') { 
                firstCrackTime = null; secondCrackTime = null; firstCrackLogged = false; secondCrackLogged = false; inSCPhase = false;
                inFCExothermicPhase = false; fcExothermicTimer = 0;
            }
            tempDataPointsBT = [{ time: roastPhaseTimer, temp: currentBT }]; updateRoR(); 
            preheatBtn.disabled = true; chargeBtn.disabled = true; dropBtn.disabled = false;
            targetChargeTempDTInput.disabled = true; batchSizeSelect.disabled = true; 
            initialMoistureSlider.disabled = true; beanDensitySlider.disabled = true; 
            gasSlider.disabled = false; airflowSlider.disabled = false; drumSpeedSlider.disabled = false;
            updateUIDisplays(); updateChart(); startSimulationTimer(); 
        }
        
        function handleDropBeans() {
            if (roastState !== 'charged') return; 
            preDropBT = currentBT; roastState = 'cooling'; coolingTimer = 0; 
            logEvent(`Beans dropped @ BT ${safeToFixed(preDropBT)}°C. Initiating cooling. Roast Time (to drop): ${formatTime(roastPhaseTimer)}.`, true);
            dropBtn.textContent = "Cooling..."; dropBtn.disabled = true; 
            gasSlider.disabled = true; airflowSlider.disabled = true; drumSpeedSlider.disabled = true;
            manageCrackSounds(false); 
        }

        function resetRoastEssentialsForNewRoast() {
            roastPhaseTimer = 0; coolingTimer = 0;
            firstCrackTime = null; firstCrackTemp = null; firstCrackLogged = false;
            secondCrackTime = null; secondCrackTemp = null; secondCrackLogged = false; inSCPhase = false;
            inFCExothermicPhase = false; fcExothermicTimer = 0;
            controlChanges = []; tempDataPointsBT = []; preDropBT = 0; currentRoR = 0;
            
            if (chart) {
                chartData.labels = []; 
                for (let i = 0; i <= 3; i++) { 
                    chartData.datasets[i].data = [];
                }
                chart.update('none'); 
            } else {
                initializeChart(); 
            }
        }

        function resetRoast() { 
            stopSimulationTimer(); roastState = 'idle'; currentTime = 0;
            resetRoastEssentialsForNewRoast(); 
            currentBT = AMBIENT_TEMP; currentET = AMBIENT_TEMP; currentDT = AMBIENT_TEMP;
            initialMoistureSlider.value = 10; currentMoisturePercent = parseFloat(initialMoistureSlider.value);
            beanDensitySlider.value = "1.18"; currentBeanDensity = parseFloat(beanDensitySlider.value); 
            targetGasSetting = 70; gasSlider.value = targetGasSetting; effectiveGas = 0; 
            targetAirflowSetting = 20; airflowSlider.value = targetAirflowSetting; effectiveAirflow = 0;
            targetDrumSpeed = 45; drumSpeedSlider.value = targetDrumSpeed; effectiveDrumSpeed = targetDrumSpeed; 
            batchSizeSelect.value = "15"; batchSize = parseFloat(batchSizeSelect.value);
            targetChargeTempDTInput.value = "190"; targetChargeTempDT = parseFloat(targetChargeTempDTInput.value);
            initialRoastParams = {};
            eventLog.innerHTML = '<li>Simulator Idle. Set Preheat Target, Batch Size, Moisture, Density, Drum Speed.</li>';
            outcomeText.textContent = "-";
            preheatStatusDisplay.textContent = "Status: Idle";
            preheatBtn.disabled = false; chargeBtn.disabled = true; dropBtn.disabled = true; dropBtn.textContent = "Drop Beans";
            targetChargeTempDTInput.disabled = false; batchSizeSelect.disabled = false; 
            initialMoistureSlider.disabled = false; beanDensitySlider.disabled = false; 
            drumSpeedSlider.disabled = false; gasSlider.disabled = false; airflowSlider.disabled = false;
            
            clearReferenceCurveData(); 
            updateUIDisplays(); 
            if (!chart) initializeChart(); else chart.update();
        }

        function recordControlChange(type, value) {
            if (roastState === 'charged') { 
                controlChanges.push({ time: roastPhaseTimer, type, value: parseFloat(value) });
            }
        }
        saveProfileBtn.addEventListener('click', () => {
            if (chartData.labels.length === 0 && controlChanges.length === 0 && roastState === 'idle') {
                alert("No roast data to save. Please complete a roast phase."); return;
            }
            const profileName = prompt("Enter a name for this roast profile:", `Roast ${new Date().toLocaleString()}`);
            if (!profileName) return;
            const liveChartDataForSave = {
                labels: [...chartData.labels],
                bt: [...chartData.datasets[0].data], et: [...chartData.datasets[1].data],
                dt: [...chartData.datasets[2].data], ror: [...chartData.datasets[3].data]
            };
            const profileData = {
                name: profileName, timestamp: new Date().toISOString(), initialParams: initialRoastParams,
                controlChanges: controlChanges, events: { firstCrackTime, firstCrackTemp, secondCrackTime, secondCrackTemp },
                chart: liveChartDataForSave, outcome: outcomeText.innerHTML, finalDropBT: preDropBT,
                roastTimeToDrop: roastState === 'dropped' || roastState === 'cooling' ? roastPhaseTimer - coolingTimer : roastPhaseTimer,
                coolingTime: roastState === 'dropped' || roastState === 'cooling' ? coolingTimer : 0
            };
            try {
                let profiles = JSON.parse(localStorage.getItem('roastProfiles')) || [];
                profiles.push(profileData);
                localStorage.setItem('roastProfiles', JSON.stringify(profiles));
                alert(`Profile "${profileName}" saved!`);
            } catch (e) { console.error("Error saving profile:", e); alert("Failed to save profile."); }
        });
        exportProfileBtn.addEventListener('click', () => {
            if (chartData.labels.length === 0 && controlChanges.length === 0 && roastState === 'idle') {
                alert("No roast data to export."); return;
            }
            const liveChartDataForExport = {
                labels: [...chartData.labels],
                bt: [...chartData.datasets[0].data], et: [...chartData.datasets[1].data],
                dt: [...chartData.datasets[2].data], ror: [...chartData.datasets[3].data]
            };
             const profileDataToExport = {
                name: `Exported Roast ${new Date().toISOString()}`, timestamp: new Date().toISOString(), initialParams: initialRoastParams,
                controlChanges: controlChanges, events: { firstCrackTime, firstCrackTemp, secondCrackTime, secondCrackTemp },
                chart: liveChartDataForExport, outcome: outcomeText.innerHTML, finalDropBT: preDropBT,
                roastTimeToDrop: roastState === 'dropped' || roastState === 'cooling' ? roastPhaseTimer - coolingTimer : roastPhaseTimer,
                coolingTime: roastState === 'dropped' || roastState === 'cooling' ? coolingTimer : 0
            };
            const jsonString = JSON.stringify(profileDataToExport, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob); const a = document.createElement('a');
            a.href = url; a.download = `roast_profile_${Date.now()}.json`;
            document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
            logEvent("Current roast data exported.");
        });
        customImportButton.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importedProfile = JSON.parse(e.target.result);
                        loadProfileAsReference(importedProfile); 
                        alert(`Profile "${importedProfile.name || 'Imported Profile'}" loaded.`);
                    } catch (err) { console.error("Error importing profile:", err); alert("Failed to import profile. Invalid JSON."); } 
                    finally { fileInput.value = ''; }
                };
                reader.readAsText(file);
            }
        });

        function loadProfileAsReference(profile) {
            console.log("Loading profile as reference:", profile);
            if (!profile || !profile.chart || !profile.chart.labels || profile.chart.labels.length === 0) {
                logEvent("Cannot load invalid profile data (missing chart data or labels).", true);
                console.error("Invalid profile structure for reference:", profile);
                return;
            }
            
            clearReferenceCurveData(); 

            if (roastState === 'idle' && !timerInterval) { 
                chartData.labels = [...profile.chart.labels];
                chartData.datasets[4].data = [...(profile.chart.bt || [])];
                chartData.datasets[4].hidden = !(profile.chart.bt && profile.chart.bt.length > 0);
                chartData.datasets[5].data = [...(profile.chart.et || [])];
                chartData.datasets[5].hidden = !(profile.chart.et && profile.chart.et.length > 0);
                chartData.datasets[6].data = [...(profile.chart.dt || [])];
                chartData.datasets[6].hidden = !(profile.chart.dt && profile.chart.dt.length > 0);
                chartData.datasets[7].data = [...(profile.chart.ror || [])];
                chartData.datasets[7].hidden = !(profile.chart.ror && profile.chart.ror.length > 0);
                const numLabels = chartData.labels.length;
                for (let i = 0; i <= 3; i++) {
                    chartData.datasets[i].data = new Array(numLabels).fill(null);
                }
                logEvent(`Profile "${profile.name || 'Reference'}" displayed using its own time axis.`);
            } else {
                chartData.datasets[4].data = [...(profile.chart.bt || [])];
                chartData.datasets[4].hidden = !(profile.chart.bt && profile.chart.bt.length > 0);
                chartData.datasets[5].data = [...(profile.chart.et || [])];
                chartData.datasets[5].hidden = !(profile.chart.et && profile.chart.et.length > 0);
                chartData.datasets[6].data = [...(profile.chart.dt || [])];
                chartData.datasets[6].hidden = !(profile.chart.dt && profile.chart.dt.length > 0);
                chartData.datasets[7].data = [...(profile.chart.ror || [])];
                chartData.datasets[7].hidden = !(profile.chart.ror && profile.chart.ror.length > 0);
                logEvent(`Profile "${profile.name || 'Reference'}" loaded as overlay for current/next roast.`);
            }
            chart.update();
        }
    
        clearReferenceBtn.addEventListener('click', () => {
            clearReferenceCurveData();
            if (roastState === 'idle' && !timerInterval) {
                resetRoastEssentialsForNewRoast(); 
                updateChart(); 
            } else {
                chart.update();
            }
            logEvent("Reference curve cleared.");
        });

        function clearReferenceCurveData(){
            for(let i=4; i<=7; i++){ 
                if(chartData.datasets[i]) { 
                    chartData.datasets[i].data = [];
                    chartData.datasets[i].hidden = true;
                }
            }
        }
        loadProfileListBtn.addEventListener('click', () => { populateProfileList(); profileModal.style.display = 'flex'; });
        modalCloseBtn.addEventListener('click', () => { profileModal.style.display = 'none'; });
        window.addEventListener('click', (event) => { if (event.target == profileModal) profileModal.style.display = 'none'; });
        
        function populateProfileList() {
            profileList.innerHTML = ''; 
            try {
                const profiles = JSON.parse(localStorage.getItem('roastProfiles')) || [];
                if (profiles.length === 0) { profileList.innerHTML = '<li>No profiles saved.</li>'; return; }
                profiles.forEach((profile, index) => {
                    const li = document.createElement('li');
                    li.textContent = `${profile.name} (${new Date(profile.timestamp).toLocaleDateString()})`;
                    const loadBtn = document.createElement('button'); loadBtn.textContent = 'Load as Ref';
                    loadBtn.onclick = () => { loadProfileAsReference(profile); profileModal.style.display = 'none'; };
                    const deleteBtn = document.createElement('button'); deleteBtn.textContent = 'Delete';
                    deleteBtn.style.backgroundColor = '#e74c3c';
                    deleteBtn.onclick = () => {
                        if (confirm(`Delete "${profile.name}"?`)) {
                            profiles.splice(index, 1);
                            localStorage.setItem('roastProfiles', JSON.stringify(profiles));
                            populateProfileList(); 
                        }
                    };
                    const btnContainer = document.createElement('div');
                    btnContainer.appendChild(loadBtn); btnContainer.appendChild(deleteBtn);
                    li.appendChild(btnContainer); profileList.appendChild(li);
                });
            } catch(e) { profileList.innerHTML = '<li>Error loading profiles.</li>'; console.error("Error populating profile list:", e); }
        }

        // Event Listeners for controls
        preheatBtn.addEventListener('click', handlePreheat);
        chargeBtn.addEventListener('click', handleChargeBeans); 
        dropBtn.addEventListener('click', handleDropBeans);
        resetBtn.addEventListener('click', resetRoast);
        gasSlider.addEventListener('input', (e) => { targetGasSetting = parseInt(e.target.value); recordControlChange('gas', targetGasSetting); updateUIDisplays(); });
        airflowSlider.addEventListener('input', (e) => { targetAirflowSetting = parseInt(e.target.value); recordControlChange('airflow', targetAirflowSetting); updateUIDisplays(); });
        drumSpeedSlider.addEventListener('input', (e) => { targetDrumSpeed = parseInt(e.target.value); recordControlChange('drumSpeed', targetDrumSpeed); updateUIDisplays(); }); 
        batchSizeSelect.addEventListener('change', (e) => { if(roastState === 'idle' || roastState === 'preheating') batchSize = parseFloat(e.target.value); updateUIDisplays(); });
        targetChargeTempDTInput.addEventListener('change', (e) => { if(roastState === 'idle') { let nt = parseFloat(e.target.value); if (!isNaN(nt) && nt >= AMBIENT_TEMP && nt <= 300) targetChargeTempDT = nt; else e.target.value = safeToFixed(targetChargeTempDT, 0); } updateUIDisplays(); });
        initialMoistureSlider.addEventListener('input', (e) => { let nm = parseFloat(e.target.value); if(roastState === 'idle') { currentMoisturePercent = nm; } initialMoistureDisplay.textContent = `${safeToFixed(nm,1)}%`; });
        beanDensitySlider.addEventListener('input', (e) => { let nd = parseFloat(e.target.value); if (roastState === 'idle') { currentBeanDensity = nd; } beanDensityDisplay.textContent = `${safeToFixed(nd, 2)} g/mL`; });
        
        // Initial setup
        resetRoast(); 
    });
    </script>
</body>
</html>
