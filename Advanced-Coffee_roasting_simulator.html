<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holistic Roasters' Coffee Roaster Sim v3.2</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            background-color: #F5F5F5; /* Light Gray from palette */
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            color: #555759; /* Dark Gray from palette */
        }
        .container {
            background-color: #fdfdfd;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 950px;
            position: relative; 
        }
        /* REMOVED .header-logo CSS rule */
        h1 { 
            text-align: center;
            color: #555759; /* Dark Gray from palette */
            margin-bottom: 20px;
            margin-top: 20px; /* MODIFIED: Reduced margin as logo is removed */
        }
        h2 {
            text-align: center;
            color: #555759; /* Dark Gray from palette */
            margin-bottom: 20px;
        }
        h3 { /* Added basic styling for new h3 in feedback */
            margin-top: 15px;
            margin-bottom: 8px;
            color: #555759;
        }
        
        /* Tab Styles */
        .tabs-navigation {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 2px solid #ddd;
        }
        .tab-link {
            padding: 10px 20px;
            cursor: pointer;
            border: none;
            background-color: transparent;
            font-size: 1.1em;
            color: #555759; /* Dark Gray from palette */
            border-bottom: 3px solid transparent; /* For active indicator */
            margin-bottom: -2px; /* Align with container border */
            transition: color 0.3s, border-color 0.3s;
        }
        .tab-link:hover {
            color: #EF4E37; /* Red-Orange from palette */
        }
        .tab-link.active {
            color: #EF4E37; /* Red-Orange from palette */
            border-bottom-color: #EF4E37; /* Red-Orange from palette */
            font-weight: bold;
        }
        .tab-content {
            display: none; /* Hidden by default */
        }
        .tab-content.active {
            display: block; /* Shown when active */
        }

        .main-controls, .roast-parameters, .roast-info, .events, .outcome, .preheat-section, .profile-management {
            margin-bottom: 25px;
            padding: 15px;
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
        .main-controls, .profile-management {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            justify-content: space-around;
        }
        .main-controls button, .profile-management button, .profile-management input[type="file"] {
            padding: 10px 15px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.95em;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            color: white; /* Default text color for buttons with solid backgrounds */
        }
        .main-controls button:active, .profile-management button:active {
            transform: translateY(1px);
        }

        #preheatBtn { background-color: #FF7F2F; /* Orange */ }
        #chargeBtn { background-color: #EF4E37; /* Red-Orange */ }
        #dropBtn { background-color: #EF4E37; /* Red-Orange */ }
        #resetBtn { background-color: #555759; /* Dark Gray */ }
        
        .profile-management button { background-color: #6CC04A; /* Light Green */ } /* Default for load, import */
        #saveProfileBtn { background-color: #009D4E; /* Medium Green */ }
        #exportProfileBtn { background-color: #009D4E; /* Medium Green */ }
        #clearReferenceBtn { background-color: #555759; /* Dark Gray */ }
        #customImportButton { background-color: #6CC04A; /* Light Green */ }


        .main-controls button:disabled, .profile-management button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
            box-shadow: none;
        }
        .preheat-section { display: flex; gap: 15px; align-items: center; }
        .preheat-section label { font-weight: bold; }
        .preheat-section input[type="number"] { padding: 8px; border-radius: 4px; border: 1px solid #ccc; width: 80px; }
        
        .roast-parameters {
            display: flex;
            flex-direction: column; 
            gap: 20px; 
        }
        .parameter-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); 
            gap: 15px;
        }
         .parameter-row.sliders-row { 
            grid-template-columns: repeat(3, 1fr); 
        }

        .param-control { display: flex; flex-direction: column; }
        .param-control label {
            margin-bottom: 8px;
            font-weight: bold;
            color: #555759; 
        }
        .param-control input[type="range"], .param-control select {
            width: 100%;
            margin-bottom: 5px;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
            box-sizing: border-box;
        }
        .param-control span {
            font-size: 0.9em;
            color: #555759; 
            align-self: flex-end;
        }
        .roast-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 8px;
            background-color: #ecf0f1;
        }
        .info-item {
            font-size: 0.9em;
            padding: 7px;
            background-color: #fff;
            border-radius: 5px;
            border-top: 1px solid #dcdcdc;
            border-right: 1px solid #dcdcdc;
            border-bottom: 1px solid #dcdcdc;
            border-left: 1px solid #dcdcdc; 
            text-align: center;
        }
        .info-item-bt { border-left: 4px solid rgb(0, 123, 255); } 
        .info-item-et { border-left: 4px solid #EF4E37; }      
        .info-item-dt { border-left: 4px solid #009D4E; }      
        .info-item-ror { border-left: 4px solid #FFB819; }     

        .info-item strong {
            display: block;
            margin-bottom: 3px;
            color: #555759; 
        }
        .bean-visual-container { display: flex; flex-direction: column; align-items: center; justify-content: center; }
        #beanVisual { width: 25px; height: 25px; border: 1px solid #ccc; border-radius: 12px; margin-top: 4px; background-color: #90EE90; transition: background-color 0.5s ease, width 0.5s ease, height 0.5s ease; }
        .events ul { list-style-type: none; padding: 0; max-height: 120px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; border-radius: 5px; background-color: #fff; }
        .events ul li { padding: 5px 0; border-bottom: 1px dashed #eee; font-size: 0.9em; } 
        .events ul li:last-child { border-bottom: none; }
        .chart-container { width: 100%; height: 400px; margin-bottom: 20px; }
        .outcome {
            background-color: #F5F5F5; 
            border-left: 6px solid #009D4E; 
            padding: 15px;
            border-radius: 5px;
            text-align: left; /* For feedback readability */
        }
        .outcome p { margin: 5px 0; font-size: 1.0em; /* Adjusted for more text */ line-height: 1.5; }
        .outcome ul { list-style-type: disc; margin-left: 20px; padding-left: 0;}
        .outcome li { margin-bottom: 5px; }


        /* Modal Styles */
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); justify-content: center; align-items: center; }
        .modal-content { background-color: #fefefe; margin: auto; padding: 20px; border: 1px solid #888; width: 80%; max-width: 500px; border-radius: 8px; }
        .modal-close { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
        .modal-content ul { list-style-type: none; padding: 0; }
        .modal-content li { padding: 8px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; }
        .modal-content li:last-child { border-bottom: none;}
        .modal-content button { font-size: 0.8em; padding: 5px 10px; margin-left: 5px; color: white;}
        .modal-content button:first-of-type { background-color: #009D4E; }
        .modal-content button:last-of-type { background-color: #EF4E37; }

        #fileInput { display: none; }

        #instructionsTabContent {
            padding: 15px;
            line-height: 1.6;
        }
        #instructionsTabContent h3 {
            margin-top: 20px;
            margin-bottom: 10px;
            color: #555759; 
        }
        #instructionsTabContent ul {
            list-style-type: disc;
            margin-left: 20px;
        }
        #instructionsTabContent p, #instructionsTabContent li {
            margin-bottom: 10px;
        }
        #instructionsTabContent strong {
            color: #555759; 
        }
        #instructionsTabContent .parameter-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            margin-bottom: 15px;
        }
        #instructionsTabContent .parameter-table th, 
        #instructionsTabContent .parameter-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        #instructionsTabContent .parameter-table th {
            background-color: #f2f2f2;
        }

    </style>
</head>
<body>
    <div class="container">
        <!-- REMOVED <img src="https://cdn.shopify.com/s/files/1/0484/7475/1135/files/Holistic_Roasters_logo.png?v=1744162855" alt="Holistic Roasters Logo" class="header-logo"> -->
        <h1>Holistic Roasters' Probat P25 Sim</h1>

        <div class="tabs-navigation">
            <button class="tab-link active" data-tab="simulatorTabContent">Simulator</button>
            <button class="tab-link" data-tab="instructionsTabContent">Instructions</button>
        </div>

        <div id="simulatorTabContent" class="tab-content active">
            <div class="main-controls">
                <button id="preheatBtn">Preheat</button>
                <button id="chargeBtn" disabled>Charge Beans</button> 
                <button id="dropBtn" disabled>Drop Beans</button>
                <button id="resetBtn">Reset</button>
            </div>
            
            <div class="preheat-section">
                <label for="targetChargeTempDT">Target Charge DT (°C):</label>
                <input type="number" id="targetChargeTempDT" value="190" step="5">
                <span id="preheatStatus">Status: Idle</span>
            </div>
    
            <div class="profile-management">
                <button id="saveProfileBtn">Save Profile</button>
                <button id="loadProfileListBtn">Load Stored Profiles</button>
                <input type="file" id="fileInput" accept=".json">
                <button id="customImportButton">Import Profile (JSON)</button>
                <button id="exportProfileBtn">Export Current Roast Data</button>
                <button id="clearReferenceBtn">Clear Reference Curve</button>
            </div>
    
            <div class="roast-parameters">
                <div class="parameter-row">
                    <div class="param-control">
                        <label for="batchSizeSelect">Batch Size:</label>
                        <select id="batchSizeSelect">
                            <option value="10">10 kg</option>
                            <option value="15" selected>15 kg</option>
                            <option value="20">20 kg</option>
                            <option value="25">25 kg</option>
                        </select>
                        <span id="batchSizeDisplay">15 kg</span>
                    </div>
                    <div class="param-control">
                        <label for="initialMoisture">Initial Moisture (%):</label>
                        <input type="range" id="initialMoisture" min="8" max="12" value="10" step="0.5">
                        <span id="initialMoistureDisplay">10.0 %</span>
                    </div>
                    <div class="param-control">
                        <label for="beanDensitySlider">Bean Density (g/mL):</label>
                        <input type="range" id="beanDensitySlider" min="1.10" max="1.25" value="1.18" step="0.01">
                        <span id="beanDensityDisplay">1.18 g/mL</span>
                    </div>
                </div>
                <div class="parameter-row sliders-row">
                    <div class="param-control">
                        <label for="gasSlider">Gas Power (%):</label>
                        <input type="range" id="gasSlider" min="0" max="100" value="70" step="1">
                        <span id="gasValueDisplay">70 %</span>
                    </div>
                    <div class="param-control">
                        <label for="airflowSlider">Airflow Damper (%):</label>
                        <input type="range" id="airflowSlider" min="0" max="100" value="20" step="1">
                        <span id="airflowValueDisplay">20 %</span>
                    </div>
                    <div class="param-control">
                        <label for="drumSpeedSlider">Drum Speed (RPM):</label>
                        <input type="range" id="drumSpeedSlider" min="30" max="60" value="45" step="1">
                        <span id="drumSpeedDisplay">45 RPM</span>
                    </div>
                </div>
            </div>
    
            <div class="roast-info">
                <div class="info-item"><strong>Time</strong><span id="timeDisplay">0:00</span></div>
                <div class="info-item info-item-bt"><strong>BT</strong><span id="btDisplay">20.0</span>°C</div>
                <div class="info-item info-item-et"><strong>ET</strong><span id="etDisplay">20.0</span>°C</div>
                <div class="info-item info-item-dt"><strong>DT</strong><span id="dtDisplay">20.0</span>°C</div>
                <div class="info-item info-item-ror"><strong>RoR(BT)</strong><span id="rorDisplay">0.0</span>°C/m</div>
                <div class="info-item"><strong>Moisture</strong><span id="moistureDisplay">10.0</span>%</div>
                <div class="info-item bean-visual-container">
                    <strong>Bean Color</strong> <div id="beanVisual"></div>
                </div>
            </div>
    
            <div class="events">
                <h2>Events Log:</h2>
                <ul id="eventLog"><li>Simulator Idle. Set Preheat Target, Batch Size, Moisture, Density, Drum Speed.</li></ul>
            </div>
    
            <div class="chart-container"><canvas id="roastChart"></canvas></div>
            <div id="roastOutcome" class="outcome"><p id="outcomeText">-</p></div>
        </div>

        <div id="instructionsTabContent" class="tab-content">
           <h2>How to Use the Coffee Roaster Simulator</h2>
            <p>Welcome to the Holistic Roasters' Coffee Roaster Simulator! This tool allows you to practice and understand the coffee roasting process by controlling various parameters and observing their effects in real-time.</p>
            <h3>Getting Started:</h3>
            <ol>
                <li><strong>Set Initial Parameters (Before Preheat):</strong>
                    <ul>
                        <li><strong>Target Charge DT (°C):</strong> Set the desired Drum Temperature (DT) you want to reach before charging (adding) the beans. A common starting point is 180-220°C.</li>
                        <li><strong>Batch Size:</strong> Select the weight of green coffee beans you want to roast. Larger batches have more thermal mass and may react differently.</li>
                        <li><strong>Initial Moisture (%):</strong> Set the starting moisture content of the green beans. Typical range is 8-12%. Higher moisture can prolong the drying phase.</li>
                        <li><strong>Bean Density (g/mL):</strong> Set the density of the green beans. Denser beans often require more energy and may roast differently.</li>
                        <li><strong>Drum Speed (RPM):</strong> This is an initial setting before preheat. Optimal drum speed helps with even heat distribution. You can adjust this during the roast too.</li>
                    </ul>
                </li>
                <li><strong>Preheat:</strong> Click the "Preheat" button. The simulator will start heating the roaster. The "Preheat Status" will show the current Drum Temperature (DT) and Environmental Temperature (ET).</li>
                <li><strong>Charge Beans:</strong> Once the DT reaches your target (or you decide to charge earlier/later), click the "Charge Beans" button. This adds the beans to the roaster. You'll see an initial drop in temperatures as the beans absorb heat.</li>
            </ol>
            <h3>During the Roast:</h3>
            <p>Once beans are charged, you can actively control the roast:</p>
            <ul>
                <li><strong>Gas Power (%):</strong> Adjust the gas slider to increase or decrease heat input. This is your primary tool for controlling the rate of temperature rise.</li>
                <li><strong>Airflow Damper (%):</strong> Adjust the airflow. Airflow affects convective heat transfer, helps remove smoke and chaff, and can influence moisture removal and bean temperature.</li>
                <li><strong>Drum Speed (RPM):</strong> Fine-tune the drum speed. This can affect conductive (bean-to-drum) and convective (bean-to-air) heat transfer.</li>
            </ul>
            <h3>Monitoring the Roast:</h3>
            <ul>
                <li><strong>Roast Info Panel:</strong>
                    <ul>
                        <li><strong>Time:</strong> Elapsed time of the current phase (Preheat, Roast, Cooling).</li>
                        <li><strong>BT (Bean Temperature):</strong> The temperature of the coffee beans. This is a key indicator.</li>
                        <li><strong>ET (Environmental Temperature):</strong> The air temperature inside the drum.</li>
                        <li><strong>DT (Drum Temperature):</strong> The temperature of the roaster drum surface.</li>
                        <li><strong>RoR(BT) (Rate of Rise of BT):</strong> How quickly the bean temperature is increasing, measured in °C per minute. Crucial for managing roast development.</li>
                        <li><strong>Moisture:</strong> Estimated current moisture content of the beans.</li>
                        <li><strong>Bean Color:</strong> A visual representation of the beans' color changing as they roast.</li>
                    </ul>
                </li>
                <li><strong>Events Log:</strong> Shows important events like "First Crack," "Second Crack," control changes, and warnings.</li>
                <li><strong>Roast Chart:</strong> Plots BT, ET, DT, and RoR over time. This is essential for visualizing the roast profile.</li>
            </ul>
            <h3>Key Roast Milestones:</h3>
            <ul>
                <li><strong>Turning Point (TP):</strong> The point after charging where the bean temperature stops dropping and starts to rise.</li>
                <li><strong>Drying Phase:</strong> From charge until beans turn yellow (around 150-160°C BT). Focus on steady RoR.</li>
                <li><strong>Maillard Phase (Browning):</strong> From yellowing to First Crack. Development of aroma precursors. RoR typically starts to decline.</li>
                <li><strong>First Crack (FC):</strong> An audible popping sound as moisture and gases are rapidly released. Usually occurs around 195-205°C BT. This marks the beginning of "Development Time."</li>
                <li><strong>Development Time:</strong> Time from First Crack to dropping the beans. Critical for flavor development. Often expressed as Development Time Ratio (DTR) = (Development Time / Total Roast Time) * 100%. A common target DTR is 20-25%.</li>
                <li><strong>Second Crack (SC):</strong> A more rapid, crackling sound. Beans are becoming darker and oils may migrate to the surface. Occurs significantly after First Crack.</li>
            </ul>
            <h3>Ending the Roast:</h3>
            <ul>
                <li><strong>Drop Beans:</strong> When you've reached your desired roast level (based on BT, time, color, DTR, etc.), click the "Drop Beans" button. This will initiate the cooling phase.</li>
                <li><strong>Cooling:</strong> Beans are rapidly cooled to stop the roasting process. The simulation models this.</li>
                <li><strong>Roast Outcome:</strong> After cooling, a detailed analysis of the roast, including probable quality, tasting notes, and suggestions, will be displayed.</li>
            </ul>
            <h3>Profile Management:</h3>
            <ul>
                <li><strong>Save Profile:</strong> Saves the current roast data (initial settings, control changes, chart data, outcome) to your browser's local storage.</li>
                <li><strong>Load Stored Profiles:</strong> Opens a modal to view saved profiles. You can load a saved profile as a "Reference Curve" on the chart to compare with your live roast.</li>
                <li><strong>Import Profile (JSON):</strong> Load a roast profile from a .json file (if you have one exported previously or from elsewhere). This also loads as a reference curve.</li>
                <li><strong>Export Current Roast Data:</strong> Saves the data from the current (or just completed) roast as a .json file to your computer.</li>
                <li><strong>Clear Reference Curve:</strong> Removes any loaded reference profile from the chart.</li>
            </ul>
            <h3>Understanding the Parameters (Advanced):</h3>
            <table class="parameter-table">
                <thead>
                    <tr>
                        <th>Parameter</th>
                        <th>Range/Value</th>
                        <th>Impact</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Target Charge DT</td>
                        <td>~160-250°C</td>
                        <td>Higher charge temp means more initial energy into the beans.</td>
                    </tr>
                    <tr>
                        <td>Batch Size</td>
                        <td>10-25 kg</td>
                        <td>Larger batches have more thermal inertia, taking longer to heat and cool. Also affects ET drop on charge.</td>
                    </tr>
                     <tr>
                        <td>Initial Moisture</td>
                        <td>8-12%</td>
                        <td>Higher moisture may prolong drying and affect heat transfer.</td>
                    </tr>
                     <tr>
                        <td>Bean Density</td>
                        <td>1.10-1.25 g/mL</td>
                        <td>Denser beans often require more energy and may have different heat absorption characteristics, potentially shifting crack temperatures.</td>
                    </tr>
                    <tr>
                        <td>Gas Power</td>
                        <td>0-100%</td>
                        <td>Primary control for heat input. Higher gas = faster temperature rise for BT, DT, and ET (ET effect now more interactive with airflow).</td>
                    </tr>
                    <tr>
                        <td>Airflow Damper</td>
                        <td>0-100%</td>
                        <td>Affects convective heat transfer, chaff removal, and smoke. Higher airflow can increase ET with high gas by improving heat distribution from gas/DT, or cool ET/BT with low/no gas. More nuanced impact on ET calculation.</td>
                    </tr>
                    <tr>
                        <td>Drum Speed</td>
                        <td>30-60 RPM</td>
                        <td>Influences bean agitation and contact with drum/hot air. Optimal speed (around 45-50 RPM in this sim) provides balanced heat. Too slow/fast can lead to uneven roasting or inefficient transfer.</td>
                    </tr>
                </tbody>
            </table>
            <p>Experiment with different settings and control strategies to see how they affect the roast profile and outcome. Happy Roasting!</p>
        </div>
    </div>

    <!-- Profile Management Modal -->
    <div id="profileModal" class="modal">
        <div class="modal-content">
            <span class="modal-close" id="modalCloseBtn">×</span>
            <h2>Saved Roast Profiles</h2>
            <ul id="profileList">
                <!-- Profiles will be listed here -->
            </ul>
        </div>
    </div>

    <script>
    // Tab switching logic
    const tabLinks = document.querySelectorAll('.tab-link');
    const tabContents = document.querySelectorAll('.tab-content');

    tabLinks.forEach(link => {
        link.addEventListener('click', () => {
            const targetTab = link.getAttribute('data-tab');

            tabLinks.forEach(l => l.classList.remove('active'));
            tabContents.forEach(c => c.classList.remove('active'));

            link.classList.add('active');
            document.getElementById(targetTab).classList.add('active');
        });
    });

    document.addEventListener('DOMContentLoaded', () => {
        const preheatBtn = document.getElementById('preheatBtn');
        const chargeBtn = document.getElementById('chargeBtn');
        const dropBtn = document.getElementById('dropBtn');
        const resetBtn = document.getElementById('resetBtn');
        const targetChargeTempDTInput = document.getElementById('targetChargeTempDT');
        const preheatStatusDisplay = document.getElementById('preheatStatus');
        const batchSizeSelect = document.getElementById('batchSizeSelect');
        const batchSizeDisplay = document.getElementById('batchSizeDisplay');
        const initialMoistureSlider = document.getElementById('initialMoisture');
        const initialMoistureDisplay = document.getElementById('initialMoistureDisplay');
        const beanDensitySlider = document.getElementById('beanDensitySlider'); 
        const beanDensityDisplay = document.getElementById('beanDensityDisplay'); 
        const gasSlider = document.getElementById('gasSlider');
        const gasValueDisplay = document.getElementById('gasValueDisplay');
        const airflowSlider = document.getElementById('airflowSlider');
        const airflowValueDisplay = document.getElementById('airflowValueDisplay');
        const drumSpeedSlider = document.getElementById('drumSpeedSlider'); 
        const drumSpeedDisplay = document.getElementById('drumSpeedDisplay'); 
        const timeDisplay = document.getElementById('timeDisplay');
        const btDisplay = document.getElementById('btDisplay');
        const etDisplay = document.getElementById('etDisplay');
        const dtDisplay = document.getElementById('dtDisplay');
        const rorDisplay = document.getElementById('rorDisplay');
        const moistureDisplay = document.getElementById('moistureDisplay');
        const beanVisual = document.getElementById('beanVisual');
        const eventLog = document.getElementById('eventLog');
        const outcomeText = document.getElementById('outcomeText'); // Element to display detailed feedback
        const roastChartCanvas = document.getElementById('roastChart');

        const saveProfileBtn = document.getElementById('saveProfileBtn');
        const loadProfileListBtn = document.getElementById('loadProfileListBtn');
        const fileInput = document.getElementById('fileInput');
        const customImportButton = document.getElementById('customImportButton');
        const exportProfileBtn = document.getElementById('exportProfileBtn');
        const clearReferenceBtn = document.getElementById('clearReferenceBtn');
        const profileModal = document.getElementById('profileModal');
        const modalCloseBtn = document.getElementById('modalCloseBtn');
        const profileList = document.getElementById('profileList');

        let audioCtx = null;
        try {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) { console.warn("Web Audio API is not supported."); }

        let timerInterval = null, currentTime = 0, roastPhaseTimer = 0, coolingTimer = 0;
        let currentBT = 20, currentET = 20, currentDT = 20, currentRoR = 0;
        let currentMoisturePercent = parseFloat(initialMoistureSlider.value);
        let currentBeanDensity = parseFloat(beanDensitySlider.value); 
        let targetGasSetting = parseInt(gasSlider.value), effectiveGas = 0; 
        let targetAirflowSetting = parseInt(airflowSlider.value), effectiveAirflow = 0; 
        let targetDrumSpeed = parseInt(drumSpeedSlider.value), effectiveDrumSpeed = 30; 
        let batchSize = parseFloat(batchSizeSelect.value);
        let targetChargeTempDT = parseFloat(targetChargeTempDTInput.value);
        let roastState = 'idle'; 
        let firstCrackTime = null, firstCrackTemp = null, firstCrackLogged = false;
        let secondCrackTime = null, secondCrackTemp = null, secondCrackLogged = false, inSCPhase = false;
        let inFCExothermicPhase = false, fcExothermicTimer = 0;
        let crackSoundInterval = null;
        let preDropBT = 0; 

        let controlChanges = []; 
        let initialRoastParams = {}; // Will store initial settings for feedback

        let chart;
        let tempDataPointsBT = []; 
        const MAX_TEMP_DATA_POINTS_FOR_ROR = 180; 

        const getBaseChartDataStructure = () => ({
            labels: [],
            datasets: [
                { label: 'BT (°C)', data: [], borderColor: 'rgb(0, 123, 255)', yAxisID: 'y-temp', tension: 0.2, fill: false, pointRadius: 1, borderWidth: 2 },
                { label: 'ET (°C)', data: [], borderColor: '#EF4E37', yAxisID: 'y-temp', tension: 0.2, fill: false, pointRadius: 1, borderWidth: 2 },
                { label: 'DT (°C)', data: [], borderColor: '#009D4E', yAxisID: 'y-temp', tension: 0.2, fill: false, pointRadius: 1, borderWidth: 2 },
                { label: 'RoR (°C/min)', data: [], borderColor: '#FFB819', yAxisID: 'y-ror', tension: 0.2, fill: false, borderDash: [5, 5], pointRadius: 1, borderWidth: 2 },
                { label: 'Ref BT (°C)', data: [], borderColor: 'rgba(0, 123, 255, 0.4)', yAxisID: 'y-temp', tension: 0.2, fill: false, pointRadius: 0, borderDash: [3,3], borderWidth: 1.5, hidden: true },
                { label: 'Ref ET (°C)', data: [], borderColor: 'rgba(239, 78, 55, 0.4)', yAxisID: 'y-temp', tension: 0.2, fill: false, pointRadius: 0, borderDash: [3,3], borderWidth: 1.5, hidden: true },
                { label: 'Ref DT (°C)', data: [], borderColor: 'rgba(0, 157, 78, 0.4)', yAxisID: 'y-temp', tension: 0.2, fill: false, pointRadius: 0, borderDash: [3,3], borderWidth: 1.5, hidden: true },
                { label: 'Ref RoR (°C/min)', data: [], borderColor: 'rgba(255, 184, 25, 0.4)', yAxisID: 'y-ror', tension: 0.2, fill: false, borderDash: [3,3], pointRadius: 0, borderWidth: 1.5, hidden: true }
            ]
        });
        let chartData = getBaseChartDataStructure();
    
        const AMBIENT_TEMP = 20;
        const GAS_INERTIA_FACTOR = 0.08; 
        const AIRFLOW_INERTIA_FACTOR = 0.1;
        const DRUM_SPEED_INERTIA_FACTOR = 0.15; 
        const DT_HEAT_FROM_GAS_FACTOR = 0.030;
        const BT_CONDUCTIVE_FROM_DT_BASE = 0.0035;   
        const BT_CONVECTIVE_FROM_ET_AIR_BASE = 0.0025; 
        const DT_INERTIA_FACTOR = 0.03;       
        const DT_COOLING_AMBIENT_FACTOR = 0.0005;
        const DT_COOLING_FROM_BEANS_FACTOR = 0.05; 
        const PREHEAT_ET_FROM_DT_FACTOR = 0.8; 
        const PREHEAT_ET_AIRFLOW_EFFECT = 0.05; 
        const BT_INITIAL_ABSORB_FROM_DT_FACTOR = 0.6; 
        const MOISTURE_EVAPORATION_BT_FACTOR = 0.0002;    
        const MOISTURE_EVAPORATION_AIRFLOW_FACTOR = 0.0003; 
        const MOISTURE_MIN_PERCENT = 1.0;
        const DRYING_ENDOTHERMIC_STRENGTH = 0.05;     
        const DRYING_PHASE_MOISTURE_THRESHOLD = 4.0; 
        const BT_THERMAL_MASS_PENALTY_PER_KG = 0.00003; 
        const FC_ENDOTHERMIC_DIP_TEMP_RANGE = 4; 
        const FC_ENDOTHERMIC_DIP_STRENGTH = 0.10; 
        const FC_EXOTHERMIC_BOOST_STRENGTH = 0.001; 
        const FC_EXOTHERMIC_DURATION = 25; 
        const SC_TARGET_TEMP_OFFSET = 25; 
        const SC_EXOTHERMIC_DURATION = 20; 
        const OPTIMAL_DRUM_SPEED_RPM = 48;
        const DRUM_SPEED_EFFICIENCY_FACTOR_CONDUCTIVE = 0.15; 
        const DRUM_SPEED_EFFICIENCY_FACTOR_CONVECTIVE = 0.20; 
        const BASE_BEAN_DENSITY = 1.18; 
        const DENSITY_TP_BT_MODIFIER = 0.3; 
        const DENSITY_CONDUCTIVE_MULTIPLIER = 0.8; 
        const DENSITY_INERTIA_MULTIPLIER = 0.4; 
        const DENSITY_FC_TEMP_SHIFT_PER_0_01GDL = 0.15;
        const COOLING_RATE_FACTOR = 0.08; 
        const COOLING_TARGET_TEMP = 35; 
        const BEAN_VISUAL_DRYING_END_BT = 160;
        const BEAN_VISUAL_FC_START_BT_FACTOR = 0.98; 
        const ET_DROP_ON_CHARGE_BASE_FACTOR = 0.45;
        const ET_DROP_CHARGE_BATCH_SIZE_SENSITIVITY = 0.0075;
        const ET_BASE_BATCH_SIZE_FOR_CHARGE_DROP = 15;
        const ET_MAX_RISE_FROM_GAS = 280.0;
        const ET_AIRFLOW_EFFECTIVENESS_ON_GAS_HEATING_MIN = 0.35;
        const ET_AIRFLOW_EFFECTIVENESS_ON_GAS_HEATING_MAX = 1.0;
        const ET_DT_CONVERGENCE_FACTOR = 0.5;
        const ET_BT_EXCHANGE_FACTOR = 0.10;
        const ET_FIRST_CRACK_EXOTHERMIC_BOOST_DEG = 2.5;
        const ET_SECOND_CRACK_EXOTHERMIC_BOOST_DEG = 1.0;
        const ET_AIRFLOW_COOLING_LOW_GAS_THRESHOLD_GAS = 20;
        const ET_AIRFLOW_COOLING_LOW_GAS_THRESHOLD_AIRFLOW = 35;
        const ET_AIRFLOW_COOLING_LOW_GAS_FACTOR = 0.010;
        const ET_INERTIA_FACTOR = 0.20;
        const ET_AMBIENT_LOSS_FACTOR = 0.0025;

        function formatTime(seconds) { return `${Math.floor(seconds/60)}:${(Math.floor(seconds%60)+'').padStart(2,'0')}`; }
        function safeToFixed(value, digits = 1) { return (typeof value === 'number' && !isNaN(value)) ? value.toFixed(digits) : "NaN"; }

        function playCrackSound(type = 'firstCrack') {
            if (!audioCtx) return;
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            gainNode.gain.setValueAtTime(0.05, audioCtx.currentTime); 
            let baseFreq = type === 'firstCrack' ? 300 : 450;
            let duration = type === 'firstCrack' ? 0.15 : 0.1;
            oscillator.type = type === 'firstCrack' ? 'sawtooth' : 'triangle';
            oscillator.frequency.setValueAtTime(baseFreq + (Math.random() * 100 - 50), audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + duration);
            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + duration + 0.05);
        }
        function manageCrackSounds(enable, type) {
            if (enable) {
                if (crackSoundInterval) clearInterval(crackSoundInterval); 
                crackSoundInterval = setInterval(() => {
                    playCrackSound(type);
                }, Math.random() * (type === 'firstCrack' ? 1500 : 1000) + (type === 'firstCrack' ? 500 : 200)); 
            } else {
                if (crackSoundInterval) clearInterval(crackSoundInterval);
                crackSoundInterval = null;
            }
        }
        function updateUIDisplays() {
            let displayTime;
            if (roastState === 'preheating') displayTime = currentTime;
            else if (roastState === 'charged' || roastState === 'cooling') displayTime = roastPhaseTimer;
            else if (roastState === 'dropped') displayTime = roastPhaseTimer;
            else displayTime = currentTime; 

            timeDisplay.textContent = formatTime(displayTime);
            btDisplay.textContent = safeToFixed(currentBT);
            etDisplay.textContent = safeToFixed(currentET);
            dtDisplay.textContent = safeToFixed(currentDT);
            rorDisplay.textContent = safeToFixed(currentRoR);
            moistureDisplay.textContent = safeToFixed(currentMoisturePercent);
            gasValueDisplay.textContent = `${targetGasSetting}% (Eff: ${safeToFixed(effectiveGas,0)})`;
            airflowValueDisplay.textContent = `${targetAirflowSetting}% (Eff: ${safeToFixed(effectiveAirflow,0)})`;
            drumSpeedDisplay.textContent = `${targetDrumSpeed}RPM (Eff: ${safeToFixed(effectiveDrumSpeed,0)})`;
            batchSizeDisplay.textContent = `${batchSize} kg`;
            initialMoistureDisplay.textContent = `${safeToFixed(parseFloat(initialMoistureSlider.value),1)}%`;
            beanDensityDisplay.textContent = `${safeToFixed(parseFloat(beanDensitySlider.value), 2)} g/mL`; 
            targetChargeTempDTInput.value = safeToFixed(targetChargeTempDT,0);
            updateBeanVisual();
        }
        function updateBeanVisual() {
            let color = '#D2B48C'; let size = 25; 
            const fcActualTemp = firstCrackTemp || (195 + ((currentBeanDensity - BASE_BEAN_DENSITY) / 0.01) * DENSITY_FC_TEMP_SHIFT_PER_0_01GDL);
            if (currentBT <= AMBIENT_TEMP + 5 && currentMoisturePercent > 8) { color = '#90EE90'; } 
            else if (currentBT < 100) { color = '#A5D6A7'; } else if (currentBT < 130) { color = '#FFF59D'; } 
            else if (currentBT < BEAN_VISUAL_DRYING_END_BT) { color = '#FFEE58'; size = 27; } 
            else if (currentBT < fcActualTemp * BEAN_VISUAL_FC_START_BT_FACTOR) { color = '#F5DEB3'; size = 28; } 
            else if (currentBT < fcActualTemp + 5) { color = '#D2B48C'; size = 30; } 
            else if (currentBT < fcActualTemp + 12) { color = '#C19A6B'; size = 30;} 
            else if (currentBT < fcActualTemp + SC_TARGET_TEMP_OFFSET - 5) { color = '#A05A2C'; } 
            else if (currentBT < fcActualTemp + SC_TARGET_TEMP_OFFSET + 5) { color = '#80451E'; } 
            else if (currentBT < 235) { color = '#65360F'; } else if (currentBT < 245) { color = '#4A2500'; } 
            else { color = '#2F1700'; } 
            beanVisual.style.backgroundColor = color; beanVisual.style.width = `${size}px`;
            beanVisual.style.height = `${size}px`; beanVisual.style.borderRadius = `${size/2}px`;
        }
        function logEvent(message, isCritical = false) {
            const li = document.createElement('li');
            let timeMarker = `Sim [${formatTime(currentTime)}]`;
            if (roastState === 'preheating') timeMarker = `PHeat [${formatTime(currentTime)}]`;
            else if (roastState === 'charged' || roastState === 'cooling') timeMarker = `Roast [${formatTime(roastPhaseTimer)}]`;
            else if (roastState === 'dropped') timeMarker = `Roast [${formatTime(roastPhaseTimer)}] (Dropped)`;
            li.textContent = `${timeMarker} ${message}`;
            if (isCritical) {
                li.style.fontWeight = 'bold';
                li.style.color = '#EF4E37'; 
            }
            if (eventLog.firstChild && eventLog.firstChild.textContent.includes("Simulator Idle")) eventLog.removeChild(eventLog.firstChild);
            eventLog.insertBefore(li, eventLog.firstChild);
        }
        function calculateRoR() {
            const windowSeconds = 30; if (tempDataPointsBT.length < 2) return 0;
            const relevantData = tempDataPointsBT.filter(dp => roastPhaseTimer - dp.time <= windowSeconds && dp.time <= roastPhaseTimer);
            if (relevantData.length < 2) {
                if (tempDataPointsBT.length >=2) {
                    const firstPoint = tempDataPointsBT[0], lastPoint = tempDataPointsBT[tempDataPointsBT.length -1];
                    if (isNaN(firstPoint.temp) || isNaN(lastPoint.temp)) return 0; 
                    const tempChange = lastPoint.temp - firstPoint.temp, timeChange = (lastPoint.time - firstPoint.time) / 60; 
                    return timeChange > 0 ? (tempChange / timeChange) : 0;
                } return 0;
            }
            const firstPointInWindow = relevantData[0], lastPointInWindow = relevantData[relevantData.length - 1];
            if (isNaN(firstPointInWindow.temp) || isNaN(lastPointInWindow.temp)) return 0; 
            const tempChange = lastPointInWindow.temp - firstPointInWindow.temp, timeChangeInMinutes = (lastPointInWindow.time - firstPointInWindow.time) / 60;
            return timeChangeInMinutes > 0 ? (tempChange / timeChangeInMinutes) : 0;
        }
        function updateRoR() { currentRoR = parseFloat(calculateRoR()); }

        function initializeChart() {
            if (document.getElementById('simulatorTabContent').classList.contains('active') && roastChartCanvas) {
                const ctx = roastChartCanvas.getContext('2d'); if (chart) chart.destroy();
                chartData = getBaseChartDataStructure(); 
                chart = new Chart(ctx, { type: 'line', data: chartData, options: { 
                    responsive: true, maintainAspectRatio: false, interaction: { mode: 'index', intersect: false },
                    scales: { x: { title: { display: true, text: 'Time (min:sec)' } },
                        'y-temp': { type: 'linear', display: true, position: 'left', title: { display: true, text: 'Temperature (°C)' }, suggestedMin: 0, suggestedMax: 280 },
                        'y-ror': { type: 'linear', display: true, position: 'right', title: { display: true, text: 'RoR (°C/min)' }, suggestedMin: -5, suggestedMax: 30, grid: { drawOnChartArea: false } }
                    }, animation: { duration: 0 }, plugins: { tooltip: { callbacks: {
                        label: function(context) { let label = context.dataset.label || ''; if (label) label += ': ';
                            if (context.parsed.y !== null && !isNaN(context.parsed.y)) { label += context.parsed.y.toFixed(1);
                                if (context.dataset.yAxisID === 'y-temp') label += ' °C'; else if (context.dataset.yAxisID === 'y-ror') label += ' °C/min';
                            } else label += '...'; return label;
                    }}}}}});
            }
        }

        function updateChart() {
            if (!chart) { 
                if (document.getElementById('simulatorTabContent').classList.contains('active') && roastChartCanvas) {
                    initializeChart();
                    if(!chart) return; 
                } else {
                    return; 
                }
            }
            if (roastState === 'idle' && chartData.labels.length > 0 && !timerInterval) {
                 chart.update('none'); 
                 return;
            }
            if (roastState === 'dropped' && currentBT <= COOLING_TARGET_TEMP) {
                if (chartData.datasets[0].data.length > 0) chart.update('none'); 
                return;
            }
            if (roastState !== 'idle' || timerInterval) { 
                let currentChartTimeLabel = formatTime(currentTime);
                if (roastState === 'charged' || roastState === 'cooling' || roastState === 'preheating') { // Use roastPhaseTimer for charged/cooling
                     currentChartTimeLabel = (roastState === 'charged' || roastState === 'cooling') ? formatTime(roastPhaseTimer) : formatTime(currentTime);
                }
                if (chartData.labels.length === 0 || chartData.labels[chartData.labels.length - 1] !== currentChartTimeLabel) {
                    chartData.labels.push(currentChartTimeLabel);
                }
            }

            const currentDataLength = chartData.datasets[0].data.length;
            const labelsLength = chartData.labels.length;

            if (roastState !== 'idle' || (roastState === 'idle' && timerInterval) || currentDataLength < labelsLength) {
                 if (currentDataLength < labelsLength || labelsLength === 0 ) { 
                     chartData.datasets[0].data.push(isNaN(currentBT) ? null : parseFloat(currentBT.toFixed(1))); 
                     chartData.datasets[1].data.push(isNaN(currentET) ? null : parseFloat(currentET.toFixed(1)));
                     chartData.datasets[2].data.push(isNaN(currentDT) ? null : parseFloat(currentDT.toFixed(1))); 
                     chartData.datasets[3].data.push((roastState === 'charged' && !isNaN(currentRoR)) ? parseFloat(currentRoR.toFixed(1)) : null);
                } else if (currentDataLength === labelsLength && labelsLength > 0) {
                    chartData.datasets[0].data[labelsLength - 1] = isNaN(currentBT) ? null : parseFloat(currentBT.toFixed(1));
                    chartData.datasets[1].data[labelsLength - 1] = isNaN(currentET) ? null : parseFloat(currentET.toFixed(1));
                    chartData.datasets[2].data[labelsLength - 1] = isNaN(currentDT) ? null : parseFloat(currentDT.toFixed(1));
                    chartData.datasets[3].data[labelsLength - 1] = (roastState === 'charged' && !isNaN(currentRoR)) ? parseFloat(currentRoR.toFixed(1)) : null;
                }
            }

            const maxDataPointsOnChart = 900; 
            if (chartData.labels.length > maxDataPointsOnChart) { 
                chartData.labels.shift(); 
                if(roastState !== 'idle' || timerInterval) {
                    for (let i = 0; i <= 3; i++) {
                        if (chartData.datasets[i].data.length > 0) { 
                            chartData.datasets[i].data.shift();
                        }
                    }
                }
            }
            chart.update('none'); 
        }
        
        function simulationTick() {
            try { 
                if (roastState === 'preheating' || roastState === 'charged' || roastState === 'cooling') {
                    // currentTime continues to track overall sim time if needed, but roastPhaseTimer is for roast-specific phases
                }
                if (roastState !== 'preheating') currentTime++; // Increment global time if not preheating (preheat uses its own time counter for chart)
                
                effectiveGas += (targetGasSetting - effectiveGas) * GAS_INERTIA_FACTOR;
                effectiveAirflow += (targetAirflowSetting - effectiveAirflow) * AIRFLOW_INERTIA_FACTOR;
                effectiveDrumSpeed += (targetDrumSpeed - effectiveDrumSpeed) * DRUM_SPEED_INERTIA_FACTOR; 
                effectiveGas = Math.max(0, Math.min(100, effectiveGas));
                effectiveAirflow = Math.max(0, Math.min(100, effectiveAirflow));
                effectiveDrumSpeed = Math.max(30, Math.min(60, effectiveDrumSpeed)); 
            
                let dtTarget = AMBIENT_TEMP + (effectiveGas * DT_HEAT_FROM_GAS_FACTOR * 100); 
                currentDT += (dtTarget - currentDT) * DT_INERTIA_FACTOR;
                currentDT -= (currentDT - AMBIENT_TEMP) * DT_COOLING_AMBIENT_FACTOR;
                if (roastState === 'charged') { 
                    currentDT -= (currentDT - currentBT) * (batchSize / 15) * (BT_CONDUCTIVE_FROM_DT_BASE / 2);
                }
                currentDT = Math.max(AMBIENT_TEMP, currentDT);

                if (roastState === 'preheating') { 
                    currentTime++; // Dedicated time counter for preheat phase chart
                    roastPhaseTimer = 0; coolingTimer = 0;
                    let targetETForPreheat = currentDT * PREHEAT_ET_FROM_DT_FACTOR + 
                                             (effectiveAirflow - 50) * PREHEAT_ET_AIRFLOW_EFFECT * (currentDT / 200);
                    currentET += (targetETForPreheat - currentET) * ET_INERTIA_FACTOR;
                    currentET = Math.max(AMBIENT_TEMP, Math.min(currentET, currentDT + 10));
                    currentBT = AMBIENT_TEMP; currentRoR = 0;
                    if (currentDT >= targetChargeTempDT && !isNaN(targetChargeTempDT)) {
                        if (!preheatStatusDisplay.textContent.includes("Ready to Charge")) {
                             logEvent(`Preheat target ${targetChargeTempDT}°C reached. Ready to charge.`);
                        }
                        preheatStatusDisplay.textContent = `Target Reached. Ready to Charge. DT: ${safeToFixed(currentDT)}°C`;
                    } else {
                        preheatStatusDisplay.textContent = `PHeat... DT: ${safeToFixed(currentDT)} ET: ${safeToFixed(currentET)}`;
                    }
                } else if (roastState === 'charged') {
                    roastPhaseTimer++; coolingTimer = 0; 
                    if (currentMoisturePercent > MOISTURE_MIN_PERCENT && !isNaN(currentMoisturePercent)) { 
                        let moistureLoss = 0;
                        if (currentBT > AMBIENT_TEMP + 10) {
                            moistureLoss += (currentBT - (AMBIENT_TEMP + 10)) * MOISTURE_EVAPORATION_BT_FACTOR;
                            moistureLoss += (effectiveAirflow / 100) * MOISTURE_EVAPORATION_AIRFLOW_FACTOR * (currentBT / 150);
                        }
                        if(!isNaN(moistureLoss)) currentMoisturePercent -= moistureLoss;
                        currentMoisturePercent = Math.max(MOISTURE_MIN_PERCENT, currentMoisturePercent);
                    }
                    let drumSpeedDiff = Math.abs(effectiveDrumSpeed - OPTIMAL_DRUM_SPEED_RPM);
                    let conductiveEfficiency = 1.0 - (drumSpeedDiff / (OPTIMAL_DRUM_SPEED_RPM - 30)) * DRUM_SPEED_EFFICIENCY_FACTOR_CONDUCTIVE; 
                    let convectiveEfficiency = 1.0 - (drumSpeedDiff / (OPTIMAL_DRUM_SPEED_RPM - 30)) * DRUM_SPEED_EFFICIENCY_FACTOR_CONVECTIVE;
                    conductiveEfficiency = Math.max(1.0 - DRUM_SPEED_EFFICIENCY_FACTOR_CONDUCTIVE, Math.min(1.0, conductiveEfficiency)); 
                    convectiveEfficiency = Math.max(1.0 - DRUM_SPEED_EFFICIENCY_FACTOR_CONVECTIVE, Math.min(1.0, convectiveEfficiency)); 
                    const densityDiff = currentBeanDensity - BASE_BEAN_DENSITY;
                    const densityConductiveFactor = 1.0 + (densityDiff * DENSITY_CONDUCTIVE_MULTIPLIER);
                    let btConductiveGain = (currentDT - currentBT) * BT_CONDUCTIVE_FROM_DT_BASE * conductiveEfficiency * densityConductiveFactor; 
                    let airflowBoostFactor = 0.5 + (effectiveAirflow / 100) * 1.5; 
                    let btConvectiveGain = (currentET - currentBT) * BT_CONVECTIVE_FROM_ET_AIR_BASE * airflowBoostFactor * convectiveEfficiency; 
                    btConvectiveGain = Math.max(0, btConvectiveGain); 
                    let endothermicDryingEffect = 0;
                    if (currentMoisturePercent > DRYING_PHASE_MOISTURE_THRESHOLD && !isNaN(currentMoisturePercent) && !isNaN(parseFloat(initialMoistureSlider.value)) && parseFloat(initialMoistureSlider.value) !== 0) {
                        endothermicDryingEffect = (btConductiveGain + btConvectiveGain) * DRYING_ENDOTHERMIC_STRENGTH * (currentMoisturePercent / parseFloat(initialMoistureSlider.value));
                    }
                    const fcTargetTemp = 195 + ((densityDiff) / 0.01) * DENSITY_FC_TEMP_SHIFT_PER_0_01GDL;
                    const scTargetTemp = fcTargetTemp + SC_TARGET_TEMP_OFFSET;
                    let fcEndothermicDipFactor = 1.0;
                    if (!firstCrackTime && currentBT > (fcTargetTemp - FC_ENDOTHERMIC_DIP_TEMP_RANGE) && currentBT < fcTargetTemp) {
                        fcEndothermicDipFactor = 1.0 - FC_ENDOTHERMIC_DIP_STRENGTH;
                    }
                    let fcExothermicBoostBT = 0; 
                    if (inFCExothermicPhase) { 
                        fcExothermicBoostBT = FC_EXOTHERMIC_BOOST_STRENGTH; fcExothermicTimer++;
                        if (fcExothermicTimer > FC_EXOTHERMIC_DURATION) { 
                            inFCExothermicPhase = false; fcExothermicTimer = 0; manageCrackSounds(false, 'firstCrack'); 
                            logEvent("First Crack Exothermic Phase ended.");
                        }
                    }
                    let scExothermicBoostBT = 0; if (inSCPhase) { /* SC exothermic logic for BT if needed */ }
                    let thermalMassFactor = 1 - (batchSize / 50) * BT_THERMAL_MASS_PENALTY_PER_KG * (currentDT);
                    thermalMassFactor = Math.max(0.2, thermalMassFactor); 
                    let deltaBT = ((btConductiveGain + btConvectiveGain) * fcEndothermicDipFactor - endothermicDryingEffect + fcExothermicBoostBT + scExothermicBoostBT) * thermalMassFactor;
                    const densityInertiaFactor = 1.0 - (densityDiff * DENSITY_INERTIA_MULTIPLIER); 
                    if (!isNaN(deltaBT)) deltaBT *= densityInertiaFactor;
                    if (isNaN(deltaBT)) { console.error(`deltaBT is NaN...`); logEvent(`SIM WARN: deltaBT NaN.`, true);
                    } else currentBT += deltaBT;
                    currentBT = Math.max(AMBIENT_TEMP - 10, currentBT); 
                    tempDataPointsBT.push({ time: roastPhaseTimer, temp: currentBT });
                    if (tempDataPointsBT.length > MAX_TEMP_DATA_POINTS_FOR_ROR) tempDataPointsBT.shift();
                    updateRoR();

                    let targetET;
                    let airflowFactorForGasHeating = ET_AIRFLOW_EFFECTIVENESS_ON_GAS_HEATING_MIN +
                                                  (effectiveAirflow / 100) * (ET_AIRFLOW_EFFECTIVENESS_ON_GAS_HEATING_MAX - ET_AIRFLOW_EFFECTIVENESS_ON_GAS_HEATING_MIN);
                    let gasDrivenTargetETContribution = (effectiveGas / 100) * (ET_MAX_RISE_FROM_GAS - AMBIENT_TEMP) * airflowFactorForGasHeating;
                    let gasAndDtDrivenTargetET = AMBIENT_TEMP + gasDrivenTargetETContribution * (1 - ET_DT_CONVERGENCE_FACTOR) + (currentDT - AMBIENT_TEMP) * ET_DT_CONVERGENCE_FACTOR;
                    targetET = gasAndDtDrivenTargetET;
                    targetET += (currentBT - targetET) * ET_BT_EXCHANGE_FACTOR;
                    if (inFCExothermicPhase && fcExothermicTimer < (FC_EXOTHERMIC_DURATION * 0.75)) { 
                        targetET += ET_FIRST_CRACK_EXOTHERMIC_BOOST_DEG * (1 - (fcExothermicTimer / (FC_EXOTHERMIC_DURATION * 0.75)));
                    }
                    if (inSCPhase) { 
                        targetET += ET_SECOND_CRACK_EXOTHERMIC_BOOST_DEG;
                    }
                    if (effectiveGas < ET_AIRFLOW_COOLING_LOW_GAS_THRESHOLD_GAS && effectiveAirflow > ET_AIRFLOW_COOLING_LOW_GAS_THRESHOLD_AIRFLOW) {
                        let coolingMagnitude = (effectiveAirflow / 100) * ET_AIRFLOW_COOLING_LOW_GAS_FACTOR;
                        targetET -= (Math.max(0, currentET - (AMBIENT_TEMP + 5))) * coolingMagnitude;
                    }
                    currentET += (targetET - currentET) * ET_INERTIA_FACTOR;
                    currentET -= (currentET - AMBIENT_TEMP) * ET_AMBIENT_LOSS_FACTOR;
                    currentET = Math.max(AMBIENT_TEMP - 5, Math.min(currentET, currentDT + 40));

                    if (currentBT >= fcTargetTemp && !firstCrackTime) { 
                        firstCrackTime = roastPhaseTimer; firstCrackTemp = currentBT; 
                        logEvent(`First Crack @ BT ${safeToFixed(currentBT)}°C (Target: ${safeToFixed(fcTargetTemp,1)}°C, Density: ${safeToFixed(currentBeanDensity,2)} g/mL, Moisture: ${safeToFixed(currentMoisturePercent)}%)`, true); 
                        if (!firstCrackLogged) { manageCrackSounds(true, 'firstCrack'); firstCrackLogged = true; } 
                        inFCExothermicPhase = true; fcExothermicTimer = 0; 
                    }
                    if (currentBT >= scTargetTemp && firstCrackTime && !secondCrackTime) { 
                        secondCrackTime = roastPhaseTimer; secondCrackTemp = currentBT; 
                        logEvent(`Second Crack @ BT ${safeToFixed(currentBT)}°C`, true); 
                        if (!secondCrackLogged) { manageCrackSounds(true, 'secondCrack'); secondCrackLogged = true; inSCPhase = true; }
                        if(inFCExothermicPhase) { 
                            manageCrackSounds(false, 'firstCrack'); 
                            logEvent("First Crack sounds stopped due to Second Crack onset.");
                        }
                    }
                    if (currentBT >= 255 && roastState === 'charged') { logEvent(`DANGER! High BT. Auto-drop @ ${safeToFixed(currentBT)}°C`, true); handleDropBeans(); }
                } else if (roastState === 'cooling') {
                    roastPhaseTimer++; coolingTimer++;
                    let coolingEffectiveness = COOLING_RATE_FACTOR * (1 + effectiveAirflow / 150); 
                    if (currentBT > COOLING_TARGET_TEMP) {
                        currentBT -= (currentBT - (AMBIENT_TEMP/2)) * coolingEffectiveness; 
                        currentET -= (currentET - AMBIENT_TEMP) * (coolingEffectiveness * 1.5); 
                        currentDT -= (currentDT - AMBIENT_TEMP) * (coolingEffectiveness * 0.5); 
                    } else {
                        currentBT = COOLING_TARGET_TEMP; roastState = 'dropped'; stopSimulationTimer(); manageCrackSounds(false); 
                        logEvent(`Cooling complete. Final BT: ${safeToFixed(currentBT)}°C. Cooling Time: ${formatTime(coolingTimer)}`, true);
                        dropBtn.textContent = "Drop Beans"; dropBtn.disabled = false; // Re-enable drop button (though it has no function here, visual cue)
                        
                        let dtrPercent = 0; const roastDurationPreCooling = roastPhaseTimer - coolingTimer;
                        if (firstCrackTime && roastDurationPreCooling > firstCrackTime && roastDurationPreCooling > 0) {
                            const developmentTimeVal = roastDurationPreCooling - firstCrackTime;
                            dtrPercent = (developmentTimeVal / roastDurationPreCooling) * 100;
                        }
                        
                        const detailedProfileData = {
                            preDropBT: preDropBT,
                            roastDurationPreCooling: roastDurationPreCooling,
                            dtrPercent: dtrPercent,
                            firstCrackTime: firstCrackTime || 0, // Ensure it's a number
                            firstCrackTemp: firstCrackTemp,
                            initialMoisture: initialRoastParams.initialMoisture, 
                            finalMoisture: currentMoisturePercent,
                            batchSize: batchSize,
                            beanDensity: initialRoastParams.beanDensity, 
                            chartData: { 
                                labels: [...chartData.labels],
                                datasets: [ 
                                    null, null, null, 
                                    { data: [...chartData.datasets[3].data] } 
                                ]
                            },
                            controlChanges: [...controlChanges]
                        };
                        const detailedFeedback = generateDetailedRoastFeedback(detailedProfileData);
                        outcomeText.innerHTML = detailedFeedback; 
                        logEvent("Detailed roast analysis generated.");
                    }
                     currentET = Math.max(AMBIENT_TEMP, currentET); currentDT = Math.max(AMBIENT_TEMP, currentDT);
                }
                updateUIDisplays(); updateChart();
            } catch (error) { 
                console.error("Error in simulationTick:", error, error.stack); 
                logEvent(`SIMULATION ERROR: ${error.message}. Sim Halted.`, true); 
                stopSimulationTimer(); preheatStatusDisplay.textContent = "ERROR! Sim Halted."; 
            }
        }

        function generateDetailedRoastFeedback(profileData) {
            let feedbackHTML = `<h2>Roast Analysis:</h2>`;
            let suggestions = [];
            let tastingNotes = [];
            let quality = "Fair"; 

            const {
                preDropBT, roastDurationPreCooling, dtrPercent,
                firstCrackTime, firstCrackTemp,
                initialMoisture, finalMoisture,
                batchSize, beanDensity,
                chartData: roastChartData, // Renamed to avoid conflict with global chartData
            } = profileData;

            const timeToFC = (firstCrackTime || 0) / 60; 
            const developmentTime = firstCrackTime ? (roastDurationPreCooling - firstCrackTime) / 60 : 0;
            const totalRoastMinutes = roastDurationPreCooling / 60;

            if (preDropBT < 185) {
                roastLevel = "Significantly Underdeveloped";
                tastingNotes.push("Very grassy, sour, vegetal, starchy.");
                suggestions.push("Increase overall heat application or extend the roast time significantly. Ensure sufficient development after First Crack.");
                quality = "Poor";
            } else if (preDropBT < 198) {
                roastLevel = "Cinnamon / Very Light";
                if (dtrPercent < 15) {
                    tastingNotes.push("Grassy, undeveloped sweetness, high acidity (potentially tart).");
                    quality = "Needs Improvement";
                } else {
                    tastingNotes.push("Bright acidity, citrus notes, delicate florals, light body.");
                    quality = dtrPercent > 22 ? "Fair (DTR a bit long for this light)" : "Fair to Good (if intended)";
                }
            } else if (preDropBT < 210) {
                roastLevel = "City / Medium-Light";
                 if (dtrPercent < 16) {
                    tastingNotes.push("Some sweetness, but acidity might be sharp or underdeveloped notes present.");
                     quality = "Fair";
                } else if (dtrPercent > 24 && dtrPercent < 28) {
                    tastingNotes.push("Balanced acidity, good sweetness, caramel, fruit notes developing.");
                    quality = "Good";
                } else if (dtrPercent >= 28) {
                    tastingNotes.push("Muted acidity, sweetness might be overshadowed by roasty notes for this level.");
                    quality = "Fair (potentially DTR too long)";
                } else {
                     tastingNotes.push("Balanced acidity, sweetness, caramel, potential fruit notes.");
                     quality = "Good";
                }
            } else if (preDropBT < 220) {
                roastLevel = "Full City / Medium";
                if (dtrPercent < 18) {
                    tastingNotes.push("Body developing, but may lack full sweetness and complexity for this level.");
                    quality = "Fair";
                } else if (dtrPercent > 26 && dtrPercent < 30) {
                    tastingNotes.push("Rounded acidity, full sweetness, chocolate, nutty, caramel notes prominent.");
                    quality = "Good to Excellent";
                } else if (dtrPercent >= 30) {
                    tastingNotes.push("Lower acidity, dominant roasty/chocolate notes, sweetness might be slightly baked or DTR too long.");
                    quality = "Fair";
                } else {
                    tastingNotes.push("Rounded acidity, good sweetness, chocolate, nutty notes.");
                    quality = "Good";
                }
            } else if (preDropBT < 228) {
                roastLevel = "Vienna / Medium-Dark";
                 if (dtrPercent < 20) {
                    tastingNotes.push("Bold, but may lack nuanced sweetness, potentially some bitterness due to low DTR.");
                    quality = "Fair";
                } else if (dtrPercent > 28) {
                     tastingNotes.push("Smoky, bittersweet, potentially ashy if DTR too long.");
                     quality = "Fair (can easily become overdeveloped)";
                } else {
                    tastingNotes.push("Lower acidity, bittersweet chocolate, smoky notes, full body.");
                    quality = "Good (if intended)";
                }
            } else if (preDropBT < 235) {
                roastLevel = "French / Dark";
                tastingNotes.push("Smoky, bittersweet, oily, thin body, prominent roasty/burnt notes.");
                quality = "Fair (specialty character likely lost)";
            } else {
                roastLevel = "Very Dark / Burnt";
                tastingNotes.push("Ashy, burnt, acrid, very bitter, little to no origin character.");
                suggestions.push("Significantly reduce roast temperature or drop beans much earlier.");
                quality = "Poor";
            }
            feedbackHTML += `<p><strong>Overall Roast Level:</strong> ${roastLevel} (Dropped at ${preDropBT.toFixed(1)}°C).</p>`;
            feedbackHTML += `<p><strong>Total Roast Time (to drop):</strong> ${formatTime(roastDurationPreCooling)} (${totalRoastMinutes.toFixed(1)} min).</p>`;
            if (totalRoastMinutes < 7 && preDropBT > 190) {
                suggestions.push("Roast was very fast (<7 min). This can lead to underdeveloped centers or tipping/scorching. Consider lower initial gas, more gradual gas reductions, or ensure batch size isn't too small for the applied energy.");
                if (quality === "Good") quality = "Fair"; 
            } else if (totalRoastMinutes > 15 && preDropBT < 225) {
                suggestions.push("Roast was quite long (>15 min). This might lead to baked or flat flavors. Consider more aggressive heat application earlier, or ensure airflow isn't excessively cooling throughout the Maillard phase.");
                 if (quality === "Good") quality = "Fair";
            }

            if (firstCrackTime) {
                feedbackHTML += `<p><strong>First Crack:</strong> Occurred at ${formatTime(firstCrackTime)} (${timeToFC.toFixed(1)} min) at ${firstCrackTemp ? firstCrackTemp.toFixed(1) : 'N/A'}°C BT.</p>`;
                feedbackHTML += `<p><strong>Development Time:</strong> ${formatTime(roastDurationPreCooling - firstCrackTime)} (${developmentTime.toFixed(1)} min).</p>`;
                feedbackHTML += `<p><strong>Development Time Ratio (DTR):</strong> ${dtrPercent.toFixed(1)}%.</p>`;
                if (dtrPercent < 18 && preDropBT > 190) {
                    suggestions.push(`DTR is low (${dtrPercent.toFixed(1)}%). For more developed sweetness and complexity, try extending the time after First Crack. Reduce gas more gradually post-FC or drop at a slightly higher temperature, watching RoR.`);
                    if (quality === "Good") quality = "Fair"; if (quality === "Excellent") quality = "Good";
                } else if (dtrPercent > 28 && preDropBT < 230) {
                    suggestions.push(`DTR is high (${dtrPercent.toFixed(1)}%). This might mute acidity and origin complexity. Consider shortening development time by applying slightly more heat post-FC for a faster finish to the target drop temp, or dropping sooner.`);
                    if (quality === "Good") quality = "Fair"; if (quality === "Excellent") quality = "Good";
                } else if (preDropBT > 190 && quality === "Fair") quality = "Good"; 
            } else {
                feedbackHTML += `<p>First Crack was not reached. The roast was likely too short or lacked sufficient energy.</p>`;
                quality = "Poor";
            }
            
            let rorAtFC = NaN; let fcIndex = -1;
            if (firstCrackTime && roastChartData && roastChartData.labels && roastChartData.datasets[3]) {
                const targetFcLabel = formatTime(firstCrackTime);
                fcIndex = roastChartData.labels.indexOf(targetFcLabel);
                if (fcIndex !== -1 && roastChartData.datasets[3].data[fcIndex] !== null && !isNaN(roastChartData.datasets[3].data[fcIndex])) {
                    rorAtFC = roastChartData.datasets[3].data[fcIndex];
                    feedbackHTML += `<p><strong>RoR at First Crack:</strong> ${rorAtFC.toFixed(1)} °C/min.</p>`;
                    if (rorAtFC > 15 && timeToFC < 6) { 
                        suggestions.push("RoR at FC was quite high (>15°C/min). This can make the roast harder to control through FC and potentially lead to a 'runaway' exothermic reaction or uneven development. Consider reducing gas a bit more aggressively or sooner before FC starts.");
                    } else if (rorAtFC < 5 && firstCrackTemp > 190) {
                         suggestions.push("RoR at FC was low (<5°C/min), risking a stall. Ensure enough energy is carried into FC, or that gas reductions aren't too drastic just before it. Consider a slightly higher momentum.");
                    }
                }
            }

            if (fcIndex !== -1 && developmentTime > 0.5 && roastChartData.datasets[3]) {
                let avgRorPostFC = 0; let countPostFC = 0;
                const devStartIndex = fcIndex + 1;
                const devEndIndex = roastChartData.datasets[3].data.length; // End of available RoR data

                for (let i = devStartIndex; i < devEndIndex; i++) {
                    if (roastChartData.datasets[3].data[i] !== null && !isNaN(roastChartData.datasets[3].data[i])) {
                        avgRorPostFC += roastChartData.datasets[3].data[i];
                        countPostFC++;
                    }
                }
                if (countPostFC > 0) {
                    avgRorPostFC /= countPostFC;
                    if (avgRorPostFC < 2 && developmentTime > 1) { 
                        suggestions.push("Average RoR during development was very low (<2°C/min). This might lead to baked, flat, or papery flavors due to lack of thermal momentum. While RoR should decline, avoid letting it stall completely or stay very low for too long.");
                        tastingNotes.push("Potential for baked, flat notes due to low RoR in development.");
                         if (quality === "Good" || quality === "Excellent") quality = "Fair";
                    }
                }
            }

            if (initialMoisture && finalMoisture) {
                const moistureLossPercentage = initialMoisture - finalMoisture;
                feedbackHTML += `<p><strong>Estimated Moisture Loss:</strong> ${moistureLossPercentage.toFixed(1)}% (from ${initialMoisture.toFixed(1)}% to ${finalMoisture.toFixed(1)}%).</p>`;
                if (moistureLossPercentage < 10 && preDropBT > 200) {
                    suggestions.push("Estimated moisture loss is low (<10%) for this roast level. Could indicate a fast roast or insufficient airflow during key phases. Consider slightly longer drying/Maillard phase or strategic airflow increases.");
                } else if (moistureLossPercentage > 20) {
                     suggestions.push("Estimated moisture loss is high (>20%). This might be due to a very long roast or consistently high airflow. Can lead to a lighter body or dry taste.");
                }
            }
            feedbackHTML += `<p><strong>Probable Quality:</strong> ${quality}.</p>`;
            if (tastingNotes.length > 0) {
                feedbackHTML += `<h3>Potential Tasting Notes:</h3><ul>`;
                tastingNotes.forEach(note => { feedbackHTML += `<li>${note}</li>`; });
                feedbackHTML += `</ul>`;
            }
            if (suggestions.length > 0) {
                feedbackHTML += `<h3>Suggestions for Improvement:</h3><ul>`;
                suggestions.forEach(suggestion => { feedbackHTML += `<li>${suggestion}</li>`; });
                feedbackHTML += `</ul>`;
            } else {
                if (quality === "Excellent" || quality === "Good") {
                     feedbackHTML += `<p>This looks like a well-executed roast profile for its level! Consider experimenting with minor adjustments to fine-tune for specific beans or desired nuances.</p>`;
                }
            }
            return feedbackHTML;
        }
    
        function startSimulationTimer() { if (!timerInterval) timerInterval = setInterval(simulationTick, 1000); }
        function stopSimulationTimer() { manageCrackSounds(false); clearInterval(timerInterval); timerInterval = null; }
        
        function handlePreheat() {
            if (roastState !== 'idle') return;
            resetRoastEssentialsForNewRoast(); 
            targetChargeTempDT = parseFloat(targetChargeTempDTInput.value);
            if (isNaN(targetChargeTempDT) || targetChargeTempDT < AMBIENT_TEMP || targetChargeTempDT > 300) {
                alert(`Invalid Target Charge DT.`); targetChargeTempDTInput.value = "190"; targetChargeTempDT = 190; return;
            }
            roastState = 'preheating'; 
            currentTime = 0; // Reset preheat timer
            chartData.labels = []; // Clear labels for preheat phase specifically
            for(let i=0; i<=3; i++) chartData.datasets[i].data = []; // Clear data for preheat phase
            
            currentDT = AMBIENT_TEMP; currentET = AMBIENT_TEMP; currentBT = AMBIENT_TEMP; currentRoR = 0;
            currentMoisturePercent = parseFloat(initialMoistureSlider.value); 
            currentBeanDensity = parseFloat(beanDensitySlider.value); 
            batchSize = parseFloat(batchSizeSelect.value);
            effectiveDrumSpeed = parseInt(drumSpeedSlider.value);
            initialRoastParams = { 
                targetChargeTempDT, batchSize, 
                initialMoisture: currentMoisturePercent, 
                beanDensity: currentBeanDensity, 
                initialDrumSpeed: effectiveDrumSpeed 
            };
            logEvent(`Preheating. Target DT: ${targetChargeTempDT}°C. Batch: ${batchSize}kg. Moisture: ${safeToFixed(currentMoisturePercent)}%. Density: ${safeToFixed(currentBeanDensity,2)} g/mL. Drum: ${effectiveDrumSpeed}RPM.`);
            preheatStatusDisplay.textContent = `PHeat... DT: ${safeToFixed(currentDT)}`;
            targetChargeTempDTInput.disabled = true; batchSizeSelect.disabled = true; 
            initialMoistureSlider.disabled = true; beanDensitySlider.disabled = true; 
            preheatBtn.disabled = true; chargeBtn.disabled = false; resetBtn.disabled = false;
            startSimulationTimer();
        }
        function handleChargeBeans() {
            if (roastState !== 'preheating' && roastState !== 'idle') return;
            
            if (chart && roastState === 'preheating') { // Clear preheat chart data before starting roast phase data
                chartData.labels = [];
                for(let i=0; i<=3; i++) chartData.datasets[i].data = [];
            }
            
            if (roastState === 'idle') {
                if (!confirm("Preheat not initiated. Charge with ambient settings?")) return;
                resetRoastEssentialsForNewRoast(); 
                currentMoisturePercent = parseFloat(initialMoistureSlider.value);
                currentBeanDensity = parseFloat(beanDensitySlider.value);
                batchSize = parseFloat(batchSizeSelect.value);
                effectiveDrumSpeed = parseInt(drumSpeedSlider.value); 
                initialRoastParams = { 
                    targetChargeTempDT: currentDT, batchSize, 
                    initialMoisture: currentMoisturePercent, 
                    beanDensity: currentBeanDensity, 
                    initialDrumSpeed: effectiveDrumSpeed 
                };
            } else { // Coming from preheating, make sure initialRoastParams is set
                 initialRoastParams = { 
                    targetChargeTempDT: targetChargeTempDT, // Use the targeted one
                    batchSize: batchSize, 
                    initialMoisture: parseFloat(initialMoistureSlider.value), 
                    beanDensity: parseFloat(beanDensitySlider.value), 
                    initialDrumSpeed: parseInt(drumSpeedSlider.value)
                };
            }

            roastState = 'charged'; roastPhaseTimer = 0; currentTime = 0; // Reset roastPhaseTimer for roast itself, currentTime too for chart label sync
            const dtBeforeCharge = currentDT;
            currentDT -= (dtBeforeCharge - AMBIENT_TEMP) * (batchSize / 50) * DT_COOLING_FROM_BEANS_FACTOR; 
            let batchSizeDeviationEffect = (batchSize - ET_BASE_BATCH_SIZE_FOR_CHARGE_DROP) * ET_DROP_CHARGE_BATCH_SIZE_SENSITIVITY;
            let dynamicChargeDropFactor = Math.min(0.85, Math.max(0.2, ET_DROP_ON_CHARGE_BASE_FACTOR + batchSizeDeviationEffect));
            currentET = AMBIENT_TEMP + (currentET - AMBIENT_TEMP) * (1 - dynamicChargeDropFactor); 
            const densityDiff = currentBeanDensity - BASE_BEAN_DENSITY;
            const densityTpModifier = 1.0 + (densityDiff * DENSITY_TP_BT_MODIFIER);
            currentBT = AMBIENT_TEMP + (dtBeforeCharge - AMBIENT_TEMP) * BT_INITIAL_ABSORB_FROM_DT_FACTOR * (1 - batchSize/100) * densityTpModifier;
            currentBT = Math.max(AMBIENT_TEMP / 1.5, currentBT); 
            logEvent(`Beans Charged! DT: ${safeToFixed(currentDT)}, ET: ${safeToFixed(currentET)}, BT: ${safeToFixed(currentBT)} (TP). Moisture: ${safeToFixed(currentMoisturePercent)}%, Density: ${safeToFixed(currentBeanDensity,2)} g/mL`, true);
            preheatStatusDisplay.textContent = 'Beans Charged';
            
            firstCrackTime = null; secondCrackTime = null; firstCrackLogged = false; secondCrackLogged = false; inSCPhase = false;
            inFCExothermicPhase = false; fcExothermicTimer = 0;
            
            tempDataPointsBT = [{ time: roastPhaseTimer, temp: currentBT }]; updateRoR(); 
            preheatBtn.disabled = true; chargeBtn.disabled = true; dropBtn.disabled = false;
            targetChargeTempDTInput.disabled = true; batchSizeSelect.disabled = true; 
            initialMoistureSlider.disabled = true; beanDensitySlider.disabled = true; 
            gasSlider.disabled = false; airflowSlider.disabled = false; drumSpeedSlider.disabled = false;
            updateUIDisplays(); updateChart(); 
            if (!timerInterval) startSimulationTimer(); // Ensure timer starts if it was idle
        }
        
        function handleDropBeans() {
            if (roastState !== 'charged') return; 
            preDropBT = currentBT; roastState = 'cooling'; coolingTimer = 0; 
            logEvent(`Beans dropped @ BT ${safeToFixed(preDropBT)}°C. Initiating cooling. Roast Time (to drop): ${formatTime(roastPhaseTimer)}.`, true);
            dropBtn.textContent = "Cooling..."; dropBtn.disabled = true; 
            gasSlider.disabled = true; 
            drumSpeedSlider.disabled = true;
            manageCrackSounds(false); 
        }

        function resetRoastEssentialsForNewRoast() {
            roastPhaseTimer = 0; coolingTimer = 0;
            firstCrackTime = null; firstCrackTemp = null; firstCrackLogged = false;
            secondCrackTime = null; secondCrackTemp = null; secondCrackLogged = false; inSCPhase = false;
            inFCExothermicPhase = false; fcExothermicTimer = 0;
            controlChanges = []; tempDataPointsBT = []; preDropBT = 0; currentRoR = 0;
            initialRoastParams = {}; // Clear initial params for a fresh start
            
            if (chart) {
                chartData.labels = []; 
                for (let i = 0; i <= 3; i++) { 
                    chartData.datasets[i].data = [];
                }
                chart.update('none'); 
            } else {
                initializeChart(); 
            }
        }

        function resetRoast() { 
            stopSimulationTimer(); roastState = 'idle'; currentTime = 0;
            resetRoastEssentialsForNewRoast(); 
            currentBT = AMBIENT_TEMP; currentET = AMBIENT_TEMP; currentDT = AMBIENT_TEMP;
            initialMoistureSlider.value = 10; currentMoisturePercent = parseFloat(initialMoistureSlider.value);
            beanDensitySlider.value = "1.18"; currentBeanDensity = parseFloat(beanDensitySlider.value); 
            targetGasSetting = 70; gasSlider.value = targetGasSetting; effectiveGas = 0; 
            targetAirflowSetting = 20; airflowSlider.value = targetAirflowSetting; effectiveAirflow = 0;
            targetDrumSpeed = 45; drumSpeedSlider.value = targetDrumSpeed; effectiveDrumSpeed = targetDrumSpeed; 
            batchSizeSelect.value = "15"; batchSize = parseFloat(batchSizeSelect.value);
            targetChargeTempDTInput.value = "190"; targetChargeTempDT = parseFloat(targetChargeTempDTInput.value);
            
            eventLog.innerHTML = '<li>Simulator Idle. Set Preheat Target, Batch Size, Moisture, Density, Drum Speed.</li>';
            outcomeText.innerHTML = "<p>-</p>"; // Reset outcome to simple placeholder
            preheatStatusDisplay.textContent = "Status: Idle";
            preheatBtn.disabled = false; chargeBtn.disabled = true; dropBtn.disabled = true; dropBtn.textContent = "Drop Beans";
            targetChargeTempDTInput.disabled = false; batchSizeSelect.disabled = false; 
            initialMoistureSlider.disabled = false; beanDensitySlider.disabled = false; 
            drumSpeedSlider.disabled = false; gasSlider.disabled = false; airflowSlider.disabled = false;
            
            updateUIDisplays(); 
            if (!chart) initializeChart(); else chart.update();
        }

        function recordControlChange(type, value) {
            if (roastState === 'charged') { 
                controlChanges.push({ time: roastPhaseTimer, type, value: parseFloat(value) });
            }
        }
        saveProfileBtn.addEventListener('click', () => {
            if (chartData.labels.length === 0 && controlChanges.length === 0 && roastState === 'idle' && outcomeText.textContent === "-") {
                alert("No roast data to save. Please complete a roast phase."); return;
            }
            const profileName = prompt("Enter a name for this roast profile:", `Roast ${new Date().toLocaleString()}`);
            if (!profileName) return;
            const liveChartDataForSave = {
                labels: [...chartData.labels],
                bt: [...chartData.datasets[0].data], et: [...chartData.datasets[1].data],
                dt: [...chartData.datasets[2].data], ror: [...chartData.datasets[3].data]
            };
            const profileData = {
                name: profileName, timestamp: new Date().toISOString(), 
                initialParams: {...initialRoastParams}, // Save a copy
                controlChanges: controlChanges, 
                events: { firstCrackTime, firstCrackTemp, secondCrackTime, secondCrackTemp },
                chart: liveChartDataForSave, 
                outcomeHTML: outcomeText.innerHTML, // Save the generated HTML feedback
                finalDropBT: preDropBT,
                roastTimeToDrop: (roastState === 'dropped' || roastState === 'cooling') ? roastPhaseTimer - coolingTimer : roastPhaseTimer,
                coolingTime: (roastState === 'dropped' || roastState === 'cooling') ? coolingTimer : 0,
                // Explicitly save these as they are part of initialRoastParams but good to have top-level too
                batchSize: initialRoastParams.batchSize, 
                initialMoisture: initialRoastParams.initialMoisture,
                beanDensity: initialRoastParams.beanDensity
            };
            try {
                let profiles = JSON.parse(localStorage.getItem('roastProfiles')) || [];
                profiles.push(profileData);
                localStorage.setItem('roastProfiles', JSON.stringify(profiles));
                alert(`Profile "${profileName}" saved!`);
            } catch (e) { console.error("Error saving profile:", e); alert("Failed to save profile."); }
        });
        exportProfileBtn.addEventListener('click', () => {
             if (chartData.labels.length === 0 && controlChanges.length === 0 && roastState === 'idle' && outcomeText.textContent === "-") {
                alert("No roast data to export."); return;
            }
            const liveChartDataForExport = {
                labels: [...chartData.labels],
                bt: [...chartData.datasets[0].data], et: [...chartData.datasets[1].data],
                dt: [...chartData.datasets[2].data], ror: [...chartData.datasets[3].data]
            };
             const profileDataToExport = {
                name: `Exported Roast ${new Date().toISOString()}`, timestamp: new Date().toISOString(), 
                initialParams: {...initialRoastParams},
                controlChanges: controlChanges, 
                events: { firstCrackTime, firstCrackTemp, secondCrackTime, secondCrackTemp },
                chart: liveChartDataForExport, outcomeHTML: outcomeText.innerHTML, finalDropBT: preDropBT,
                roastTimeToDrop: (roastState === 'dropped' || roastState === 'cooling') ? roastPhaseTimer - coolingTimer : roastPhaseTimer,
                coolingTime: (roastState === 'dropped' || roastState === 'cooling') ? coolingTimer : 0,
                batchSize: initialRoastParams.batchSize, 
                initialMoisture: initialRoastParams.initialMoisture,
                beanDensity: initialRoastParams.beanDensity
            };
            const jsonString = JSON.stringify(profileDataToExport, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob); const a = document.createElement('a');
            a.href = url; a.download = `roast_profile_${Date.now()}.json`;
            document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
            logEvent("Current roast data exported.");
        });
        customImportButton.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importedProfile = JSON.parse(e.target.result);
                        loadProfileAsReference(importedProfile); 
                        if (roastState === 'idle' && importedProfile.initialParams) {
                            if (typeof importedProfile.initialParams.batchSize !== 'undefined') batchSizeSelect.value = importedProfile.initialParams.batchSize;
                            if (typeof importedProfile.initialParams.initialMoisture !== 'undefined') initialMoistureSlider.value = importedProfile.initialParams.initialMoisture;
                            if (typeof importedProfile.initialParams.beanDensity !== 'undefined') beanDensitySlider.value = importedProfile.initialParams.beanDensity;
                            if (typeof importedProfile.initialParams.targetChargeTempDT !== 'undefined') targetChargeTempDTInput.value = importedProfile.initialParams.targetChargeTempDT;
                            if (typeof importedProfile.initialParams.initialDrumSpeed !== 'undefined') drumSpeedSlider.value = importedProfile.initialParams.initialDrumSpeed;


                            batchSize = parseFloat(batchSizeSelect.value);
                            currentMoisturePercent = parseFloat(initialMoistureSlider.value);
                            currentBeanDensity = parseFloat(beanDensitySlider.value);
                            targetChargeTempDT = parseFloat(targetChargeTempDTInput.value);
                            targetDrumSpeed = parseInt(drumSpeedSlider.value);
                            
                            // Update initialRoastParams for the current (potentially new) roast
                            initialRoastParams = { ...importedProfile.initialParams }; 

                            updateUIDisplays();
                            logEvent("Initial parameters updated from imported reference profile.");
                        }
                         if(importedProfile.outcomeHTML && roastState === 'idle'){ // If loading a full profile including outcome
                            outcomeText.innerHTML = importedProfile.outcomeHTML;
                        }
                        alert(`Profile "${importedProfile.name || 'Imported Profile'}" loaded as reference.`);
                    } catch (err) { console.error("Error importing profile:", err); alert("Failed to import profile. Invalid JSON."); } 
                    finally { fileInput.value = ''; }
                };
                reader.readAsText(file);
            }
        });

        function loadProfileAsReference(profile) {
            if (!profile || !profile.chart || !profile.chart.labels || profile.chart.labels.length === 0) {
                logEvent("Cannot load invalid profile data (missing chart data or labels).", true);
                return;
            }
            clearReferenceCurveData(); 
            if (roastState === 'idle' && !timerInterval) { 
                chartData.labels = [...profile.chart.labels];
                chartData.datasets[4].data = [...(profile.chart.bt || [])];
                chartData.datasets[4].hidden = !(profile.chart.bt && profile.chart.bt.length > 0);
                chartData.datasets[5].data = [...(profile.chart.et || [])];
                chartData.datasets[5].hidden = !(profile.chart.et && profile.chart.et.length > 0);
                chartData.datasets[6].data = [...(profile.chart.dt || [])];
                chartData.datasets[6].hidden = !(profile.chart.dt && profile.chart.dt.length > 0);
                chartData.datasets[7].data = [...(profile.chart.ror || [])];
                chartData.datasets[7].hidden = !(profile.chart.ror && profile.chart.ror.length > 0);
                const numLabels = chartData.labels.length;
                for (let i = 0; i <= 3; i++) { 
                    chartData.datasets[i].data = new Array(numLabels).fill(null);
                }
                logEvent(`Profile "${profile.name || 'Reference'}" displayed using its own time axis.`);
            } else { 
                chartData.datasets[4].data = [...(profile.chart.bt || [])];
                chartData.datasets[4].hidden = !(profile.chart.bt && profile.chart.bt.length > 0);
                chartData.datasets[5].data = [...(profile.chart.et || [])];
                chartData.datasets[5].hidden = !(profile.chart.et && profile.chart.et.length > 0);
                chartData.datasets[6].data = [...(profile.chart.dt || [])];
                chartData.datasets[6].hidden = !(profile.chart.dt && profile.chart.dt.length > 0);
                chartData.datasets[7].data = [...(profile.chart.ror || [])];
                chartData.datasets[7].hidden = !(profile.chart.ror && profile.chart.ror.length > 0);
                logEvent(`Profile "${profile.name || 'Reference'}" loaded as overlay for current/next roast.`);
            }
            if (chart) chart.update(); else if (document.getElementById('simulatorTabContent').classList.contains('active')) initializeChart();
        }
    
        clearReferenceBtn.addEventListener('click', () => {
            clearReferenceCurveData();
            if (roastState === 'idle' && !timerInterval && chartData.datasets[0].data.every(d => d === null)) { 
                chartData.labels = [];
                 for (let i = 0; i <= 3; i++) { 
                    chartData.datasets[i].data = [];
                }
            }
            if (chart) chart.update();
            logEvent("Reference curve cleared.");
        });

        function clearReferenceCurveData(){
            for(let i=4; i<=7; i++){ 
                if(chartData.datasets[i]) { 
                    chartData.datasets[i].data = [];
                    chartData.datasets[i].hidden = true;
                }
            }
        }
        loadProfileListBtn.addEventListener('click', () => { populateProfileList(); profileModal.style.display = 'flex'; });
        modalCloseBtn.addEventListener('click', () => { profileModal.style.display = 'none'; });
        window.addEventListener('click', (event) => { if (event.target == profileModal) profileModal.style.display = 'none'; });
        
        function populateProfileList() {
            profileList.innerHTML = ''; 
            try {
                const profiles = JSON.parse(localStorage.getItem('roastProfiles')) || [];
                if (profiles.length === 0) { profileList.innerHTML = '<li>No profiles saved.</li>'; return; }
                profiles.sort((a,b) => new Date(b.timestamp) - new Date(a.timestamp)); 
                profiles.forEach((profile) => {
                    const li = document.createElement('li');
                    const profileDesc = `${profile.name || 'Unnamed Profile'} (${new Date(profile.timestamp).toLocaleDateString()}) 
                        ${profile.batchSize ? 'BS:'+profile.batchSize+'kg' : ''} 
                        ${profile.initialMoisture ? 'M:'+profile.initialMoisture.toFixed(1)+'%' : ''} 
                        ${profile.beanDensity ? 'D:'+profile.beanDensity.toFixed(2)+'g/mL' : ''}`;
                    li.textContent = profileDesc.trim();

                    const loadBtn = document.createElement('button'); loadBtn.textContent = 'Load as Ref';
                    loadBtn.onclick = () => { 
                        loadProfileAsReference(profile); 
                        if (roastState === 'idle' && profile.initialParams) {
                             if (typeof profile.initialParams.batchSize !== 'undefined') batchSizeSelect.value = profile.initialParams.batchSize;
                             if (typeof profile.initialParams.initialMoisture !== 'undefined') initialMoistureSlider.value = profile.initialParams.initialMoisture;
                             if (typeof profile.initialParams.beanDensity !== 'undefined') beanDensitySlider.value = profile.initialParams.beanDensity;
                             if (typeof profile.initialParams.targetChargeTempDT !== 'undefined') targetChargeTempDTInput.value = profile.initialParams.targetChargeTempDT;
                             if (typeof profile.initialParams.initialDrumSpeed !== 'undefined') drumSpeedSlider.value = profile.initialParams.initialDrumSpeed;
                             
                             batchSize = parseFloat(batchSizeSelect.value);
                             currentMoisturePercent = parseFloat(initialMoistureSlider.value);
                             currentBeanDensity = parseFloat(beanDensitySlider.value);
                             targetChargeTempDT = parseFloat(targetChargeTempDTInput.value);
                             targetDrumSpeed = parseInt(drumSpeedSlider.value);

                             initialRoastParams = { ...profile.initialParams };
                             updateUIDisplays();
                             logEvent("Initial parameters updated from loaded reference profile.");
                        }
                         if(profile.outcomeHTML && roastState === 'idle'){
                            outcomeText.innerHTML = profile.outcomeHTML;
                        }
                        profileModal.style.display = 'none'; 
                    };
                    const deleteBtn = document.createElement('button'); deleteBtn.textContent = 'Delete';
                    deleteBtn.onclick = () => {
                        if (confirm(`Delete "${profile.name || 'Unnamed Profile'}"? This cannot be undone.`)) {
                            const updatedProfiles = profiles.filter(p => p.timestamp !== profile.timestamp);
                            localStorage.setItem('roastProfiles', JSON.stringify(updatedProfiles));
                            populateProfileList(); 
                        }
                    };
                    const btnContainer = document.createElement('div');
                    btnContainer.appendChild(loadBtn); btnContainer.appendChild(deleteBtn);
                    li.appendChild(btnContainer); profileList.appendChild(li);
                });
            } catch(e) { profileList.innerHTML = '<li>Error loading profiles.</li>'; console.error("Error populating profile list:", e); }
        }

        preheatBtn.addEventListener('click', handlePreheat);
        chargeBtn.addEventListener('click', handleChargeBeans); 
        dropBtn.addEventListener('click', handleDropBeans);
        resetBtn.addEventListener('click', resetRoast);
        gasSlider.addEventListener('input', (e) => { targetGasSetting = parseInt(e.target.value); recordControlChange('gas', targetGasSetting); updateUIDisplays(); });
        airflowSlider.addEventListener('input', (e) => { targetAirflowSetting = parseInt(e.target.value); recordControlChange('airflow', targetAirflowSetting); updateUIDisplays(); });
        drumSpeedSlider.addEventListener('input', (e) => { targetDrumSpeed = parseInt(e.target.value); recordControlChange('drumSpeed', targetDrumSpeed); updateUIDisplays(); }); 
        batchSizeSelect.addEventListener('change', (e) => { if(roastState === 'idle' || roastState === 'preheating') batchSize = parseFloat(e.target.value); updateUIDisplays(); });
        targetChargeTempDTInput.addEventListener('change', (e) => { if(roastState === 'idle') { let nt = parseFloat(e.target.value); if (!isNaN(nt) && nt >= AMBIENT_TEMP && nt <= 300) targetChargeTempDT = nt; else e.target.value = safeToFixed(targetChargeTempDT, 0); } updateUIDisplays(); });
        initialMoistureSlider.addEventListener('input', (e) => { let nm = parseFloat(e.target.value); if(roastState === 'idle') { currentMoisturePercent = nm; } initialMoistureDisplay.textContent = `${safeToFixed(nm,1)}%`; });
        beanDensitySlider.addEventListener('input', (e) => { let nd = parseFloat(e.target.value); if (roastState === 'idle') { currentBeanDensity = nd; } beanDensityDisplay.textContent = `${safeToFixed(nd, 2)} g/mL`; });
        
        if (document.getElementById('simulatorTabContent').classList.contains('active')) {
            resetRoast(); 
        } else {
            stopSimulationTimer(); roastState = 'idle'; currentTime = 0;
            currentBT = AMBIENT_TEMP; currentET = AMBIENT_TEMP; currentDT = AMBIENT_TEMP;
            initialMoistureSlider.value = 10; currentMoisturePercent = parseFloat(initialMoistureSlider.value);
            updateUIDisplays(); 
        }
        document.querySelector('.tab-link[data-tab="simulatorTabContent"]').addEventListener('click', () => {
            if (!chart && roastChartCanvas) {
                initializeChart();
                if(chart && chartData.labels.length > 0) chart.update(); 
            }
        });
    });
    </script>
</body>
</html>
